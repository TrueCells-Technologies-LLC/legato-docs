<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Legato: framework/c/inc/le_hashmap.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo">
    <img alt="Logo" src="legatoLogo.png"/>
    <div id="projectbrief">Wireless M2M smooth and connected</div>
  </td>
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('le__hashmap_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">framework/c/inc/le_hashmap.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="le__hashmap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct le_hashmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct le_hashmap_It *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#acad41c860fc56cf2a6a131ff9fa903ac">le_hashmap_HashFunc_t</a> )(const void *keyToHashPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a6ee5c91b9ed171224914d99d71cdc097">le_hashmap_EqualsFunc_t</a> )(const void *firstKeyPtr, const void *secondKeyPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ad19da37ee07973a5de5eee458d3c5d60">le_hashmap_ForEachHandler_t</a> )(const void *keyPtr, const void *valuePtr, void *contextPtr)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create</a> (const char *nameStr, size_t capacity, <a class="el" href="le__hashmap_8h.html#acad41c860fc56cf2a6a131ff9fa903ac">le_hashmap_HashFunc_t</a> hashFunc, <a class="el" href="le__hashmap_8h.html#a6ee5c91b9ed171224914d99d71cdc097">le_hashmap_EqualsFunc_t</a> equalsFunc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a68759fb8291c487a507eae6d92710fc7">le_hashmap_Put</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const void *keyPtr, const void *valuePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a4322a312a2e4b00112022c2cb04eb416">le_hashmap_Get</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const void *keyPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a64eab4c096da5b66aa54c70ec5d5a776">le_hashmap_Remove</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const void *keyPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a5530fc9656f5e49f891541900bc21f34">le_hashmap_isEmpty</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a481e3fa6b0fe8319074140a2cb2ae1cc">le_hashmap_Size</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#af42bc33eaed4e6183edfbded3203beb4">le_hashmap_ContainsKey</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const void *keyPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a27e3af23871a2f9e8adffb748111aab2">le_hashmap_RemoveAll</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a2fc335fffcf59a677ac2ac4e5733cdda">le_hashmap_ForEach</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, <a class="el" href="le__hashmap_8h.html#ad19da37ee07973a5de5eee458d3c5d60">le_hashmap_ForEachHandler_t</a> forEachFn, void *contextPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a8fb1d3a3d4c4b1b52a45205ac11a12c1">le_hashmap_GetIterator</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a8c983aea3bfa393419b4ea26cfe35f42">le_hashmap_GetKey</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#aefd09b502200c3260a047cb12097e8ad">le_hashmap_GetValue</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#aeec5d4c2a49b8d0304efdfd469a1b2a4">le_hashmap_GetFirstNode</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, void **firstKeyPtr, void **firstValuePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a6a30f4e7da8135ef0274b24a86b7fcb7">le_hashmap_GetNodeAfter</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const void *keyPtr, void **nextKeyPtr, void **nextValuePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ad31a0f34a74f765998467fa30096e46b">le_hashmap_CountCollisions</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a3ff75de814b38d4c4283379acb406b65">le_hashmap_HashString</a> (const void *stringToHashPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a63d2b6c0689ece50ce979557029b8483">le_hashmap_EqualsString</a> (const void *firstStringPtr, const void *secondStringPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a1bcf5d26bec7e15b6ec30fec4701ce03">le_hashmap_HashUInt32</a> (const void *intToHashPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ab3e3edfdbd30d06729486060a75a77c7">le_hashmap_EqualsUInt32</a> (const void *firstIntPtr, const void *secondIntPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a2c9fc51c9f65c44f6c78cdaf101ab0e4">le_hashmap_HashVoidPointer</a> (const void *voidToHashPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a8ecdbbdb5cc0773f0f9946e6e4dec89c">le_hashmap_EqualsVoidPointer</a> (const void *firstVoidPtr, const void *secondVoidPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a853082500b05e57d899606cfc0e34fab">le_hashmap_MakeTraceable</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a10b30e794df1c866fe39c40c7949eb29">le_hashmap_EnableTrace</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Legato <a class="el" href="c_hashmap.html">HashMap API</a> include file.</p>
<p>Copyright (C) Sierra Wireless, Inc. 2014. All rights reserved. Use of this work is subject to license. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a6ee5c91b9ed171224914d99d71cdc097"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_EqualsFunc_t" ref="a6ee5c91b9ed171224914d99d71cdc097" args=")(const void *firstKeyPtr, const void *secondKeyPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* <a class="el" href="le__hashmap_8h.html#a6ee5c91b9ed171224914d99d71cdc097">le_hashmap_EqualsFunc_t</a>)(const void *firstKeyPtr, const void *secondKeyPtr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prototype for equality functions. The equality function returns true if the the keys point to values are equivalent. The HashMap doesn't know in advance which types are to be stored so this function must be supplied by the caller.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">firstKeyPtr</td><td>Pointer to the first key for comparing. </td></tr>
    <tr><td class="paramname">secondKeyPtr</td><td>Pointer to the second key for comparing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the values are the same, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad19da37ee07973a5de5eee458d3c5d60"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_ForEachHandler_t" ref="ad19da37ee07973a5de5eee458d3c5d60" args=")(const void *keyPtr, const void *valuePtr, void *contextPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* <a class="el" href="le__hashmap_8h.html#ad19da37ee07973a5de5eee458d3c5d60">le_hashmap_ForEachHandler_t</a>)(const void *keyPtr, const void *valuePtr, void *contextPtr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prototype for callback functions for the iterator function <a class="el" href="le__hashmap_8h.html#a2fc335fffcf59a677ac2ac4e5733cdda">le_hashmap_ForEach()</a>. This function should return true in order to continue iterating, or false to stop.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keyPtr</td><td>Pointer to the key at the current position in the map </td></tr>
    <tr><td class="paramname">valuePtr</td><td>Pointer to the value associated to this key </td></tr>
    <tr><td class="paramname">contextPtr</td><td>Pointer to the context supplied to <a class="el" href="le__hashmap_8h.html#a2fc335fffcf59a677ac2ac4e5733cdda">le_hashmap_ForEach()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true to continue, false to stop </dd></dl>

</div>
</div>
<a class="anchor" id="acad41c860fc56cf2a6a131ff9fa903ac"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_HashFunc_t" ref="acad41c860fc56cf2a6a131ff9fa903ac" args=")(const void *keyToHashPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* <a class="el" href="le__hashmap_8h.html#acad41c860fc56cf2a6a131ff9fa903ac">le_hashmap_HashFunc_t</a>)(const void *keyToHashPtr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prototype for hash functions. The hash function must generate a good spread of hashes without consuming lots of processing power.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keyToHashPtr</td><td>Pointer to the key which will be hashed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The calculated hash value </dd></dl>

</div>
</div>
<a class="anchor" id="a8ab2021261a368add28c1be14f248459"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_It_Ref_t" ref="a8ab2021261a368add28c1be14f248459" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct le_hashmap_It* <a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reference to a HashMap Iterator. </p>

</div>
</div>
<a class="anchor" id="ae81c60860dbdb8c59beaf25985e5605a"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_Ref_t" ref="ae81c60860dbdb8c59beaf25985e5605a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct le_hashmap* <a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reference to a HashMap. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af42bc33eaed4e6183edfbded3203beb4"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_ContainsKey" ref="af42bc33eaed4e6183edfbded3203beb4" args="(le_hashmap_Ref_t mapRef, const void *keyPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__hashmap_8h.html#af42bc33eaed4e6183edfbded3203beb4">le_hashmap_ContainsKey</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>keyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tests if the HashMap contains a particular key.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the key is found, false otherwise. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be searched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad31a0f34a74f765998467fa30096e46b"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_CountCollisions" ref="ad31a0f34a74f765998467fa30096e46b" args="(le_hashmap_Ref_t mapRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="le__hashmap_8h.html#ad31a0f34a74f765998467fa30096e46b">le_hashmap_CountCollisions</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Counts the total number of collisions in the map. A collision occurs when more than one entry is stored in the map at the same index.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the total collisions in the map. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade79896a5b2ceec82c570fe21f7efe3a"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_Create" ref="ade79896a5b2ceec82c570fe21f7efe3a" args="(const char *nameStr, size_t capacity, le_hashmap_HashFunc_t hashFunc, le_hashmap_EqualsFunc_t equalsFunc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nameStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#acad41c860fc56cf2a6a131ff9fa903ac">le_hashmap_HashFunc_t</a>&#160;</td>
          <td class="paramname"><em>hashFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a6ee5c91b9ed171224914d99d71cdc097">le_hashmap_EqualsFunc_t</a>&#160;</td>
          <td class="paramname"><em>equalsFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a HashMap.</p>
<p>If you create a hashmap with a smaller capacity than you actually use, then the map will continue to work, but performance will degrade the more you put in the map.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a reference to the map.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Terminates the process on failure, so no need to check the return value for errors. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nameStr</td><td>Name of the HashMap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>Size of the hashmap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashFunc</td><td>Hash function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">equalsFunc</td><td>Equality function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10b30e794df1c866fe39c40c7949eb29"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_EnableTrace" ref="a10b30e794df1c866fe39c40c7949eb29" args="(le_hashmap_Ref_t mapRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__hashmap_8h.html#a10b30e794df1c866fe39c40c7949eb29">le_hashmap_EnableTrace</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Immediately enables tracing on a particular hashmap object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63d2b6c0689ece50ce979557029b8483"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_EqualsString" ref="a63d2b6c0689ece50ce979557029b8483" args="(const void *firstStringPtr, const void *secondStringPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__hashmap_8h.html#a63d2b6c0689ece50ce979557029b8483">le_hashmap_EqualsString</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>firstStringPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>secondStringPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>String equality function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a string</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the strings are identical, false otherwise. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstStringPtr</td><td>Pointer to the first string for comparing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondStringPtr</td><td>Pointer to the second string for comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3e3edfdbd30d06729486060a75a77c7"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_EqualsUInt32" ref="ab3e3edfdbd30d06729486060a75a77c7" args="(const void *firstIntPtr, const void *secondIntPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__hashmap_8h.html#ab3e3edfdbd30d06729486060a75a77c7">le_hashmap_EqualsUInt32</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>firstIntPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>secondIntPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Integer equality function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a uint32_t.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the integers are equal, false otherwise. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIntPtr</td><td>Pointer to the first integer for comparing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondIntPtr</td><td>Pointer to the second integer for comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ecdbbdb5cc0773f0f9946e6e4dec89c"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_EqualsVoidPointer" ref="a8ecdbbdb5cc0773f0f9946e6e4dec89c" args="(const void *firstVoidPtr, const void *secondVoidPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__hashmap_8h.html#a8ecdbbdb5cc0773f0f9946e6e4dec89c">le_hashmap_EqualsVoidPointer</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>firstVoidPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>secondVoidPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer equality function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is an pointer or reference.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the pointers are equal, false otherwise </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstVoidPtr</td><td>First pointer for comparing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondVoidPtr</td><td>Second pointer for comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fc335fffcf59a677ac2ac4e5733cdda"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_ForEach" ref="a2fc335fffcf59a677ac2ac4e5733cdda" args="(le_hashmap_Ref_t mapRef, le_hashmap_ForEachHandler_t forEachFn, void *contextPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__hashmap_8h.html#a2fc335fffcf59a677ac2ac4e5733cdda">le_hashmap_ForEach</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ad19da37ee07973a5de5eee458d3c5d60">le_hashmap_ForEachHandler_t</a>&#160;</td>
          <td class="paramname"><em>forEachFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>contextPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Iterates over the whole map, calling the supplied callback with each key-value pair. If the callback returns false for any key then this function will return.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns nothing </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forEachFn</td><td>Callback function to be called with each pair. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td>Pointer to a context to be supplied to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4322a312a2e4b00112022c2cb04eb416"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_Get" ref="a4322a312a2e4b00112022c2cb04eb416" args="(le_hashmap_Ref_t mapRef, const void *keyPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="le__hashmap_8h.html#a4322a312a2e4b00112022c2cb04eb416">le_hashmap_Get</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>keyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve a value from a HashMap.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the value or NULL if the key is not found. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be retrieved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeec5d4c2a49b8d0304efdfd469a1b2a4"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_GetFirstNode" ref="aeec5d4c2a49b8d0304efdfd469a1b2a4" args="(le_hashmap_Ref_t mapRef, void **firstKeyPtr, void **firstValuePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__hashmap_8h.html#aeec5d4c2a49b8d0304efdfd469a1b2a4">le_hashmap_GetFirstNode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>firstKeyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>firstValuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the key and value of the first node stored in the hashmap. The hashmap is not sorted so this will simply return the first node stored in the map. There is no guarantee that a subsequent call to this function will return the same pair if new keys have been added to the map. If NULL is passed as the firstValuePointer then only the key will be returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>LE_OK if the first node is returned or LE_NOT_FOUND if the map is empty. LE_BAD_PARAMETER if the key is NULL. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">firstValuePtr</td><td>&gt; [out] Pointer to the first key&gt; [out] Pointer to the first value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fb1d3a3d4c4b1b52a45205ac11a12c1"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_GetIterator" ref="a8fb1d3a3d4c4b1b52a45205ac11a12c1" args="(le_hashmap_Ref_t mapRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> <a class="el" href="le__hashmap_8h.html#a8fb1d3a3d4c4b1b52a45205ac11a12c1">le_hashmap_GetIterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets an iterator for step-by-step iteration over the map. In this mode, the iteration is controlled by the calling function using the <a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> function. There is one iterator per map, and calling this function resets the iterator position to the start of the map. The iterator is not ready for data access until <a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> has been called at least once.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns A reference to a hashmap iterator which is ready for <a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> to be called on it </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c983aea3bfa393419b4ea26cfe35f42"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_GetKey" ref="a8c983aea3bfa393419b4ea26cfe35f42" args="(le_hashmap_It_Ref_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void const* <a class="el" href="le__hashmap_8h.html#a8c983aea3bfa393419b4ea26cfe35f42">le_hashmap_GetKey</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves a pointer to the key where the iterator is currently pointing. If the iterator has just been initialized and <a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> has not been called, or if the iterator has been invalidated, this will return NULL.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the current key, or NULL if the iterator has been invalidated or is not ready. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a30f4e7da8135ef0274b24a86b7fcb7"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_GetNodeAfter" ref="a6a30f4e7da8135ef0274b24a86b7fcb7" args="(le_hashmap_Ref_t mapRef, const void *keyPtr, void **nextKeyPtr, void **nextValuePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__hashmap_8h.html#a6a30f4e7da8135ef0274b24a86b7fcb7">le_hashmap_GetNodeAfter</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>keyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>nextKeyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>nextValuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the key and value of the node after the passed in key. The hashmap is not sorted so this will simply return the next node stored in the map. There is no guarantee that a subsequent call to this function will return the same pair if new keys have been added to the map. If NULL is passed as the nextValuePtr then only the key will be returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>LE_OK if the next node is returned. If the keyPtr is not found in the map then LE_BAD_PARAMETER is returned. LE_NOT_FOUND is returned if the passed in key is the last one in the map. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be searched for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nextValuePtr</td><td>&gt; [out] Pointer to the first key&gt; [out] Pointer to the first value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefd09b502200c3260a047cb12097e8ad"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_GetValue" ref="aefd09b502200c3260a047cb12097e8ad" args="(le_hashmap_It_Ref_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void const* <a class="el" href="le__hashmap_8h.html#aefd09b502200c3260a047cb12097e8ad">le_hashmap_GetValue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves a pointer to the value where the iterator is currently pointing. If the iterator has just been initialized and <a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> has not been called, or if the iterator has been invalidated, this will return NULL.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the current value, or NULL if the iterator has been invalidated or is not ready. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ff75de814b38d4c4283379acb406b65"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_HashString" ref="a3ff75de814b38d4c4283379acb406b65" args="(const void *stringToHashPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="le__hashmap_8h.html#a3ff75de814b38d4c4283379acb406b65">le_hashmap_HashString</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>stringToHashPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>String hashing function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a string.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the hash value of the string pointed to by stringToHash. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stringToHashPtr</td><td>Pointer to the string to be hashed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bcf5d26bec7e15b6ec30fec4701ce03"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_HashUInt32" ref="a1bcf5d26bec7e15b6ec30fec4701ce03" args="(const void *intToHashPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="le__hashmap_8h.html#a1bcf5d26bec7e15b6ec30fec4701ce03">le_hashmap_HashUInt32</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>intToHashPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Integer hashing function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a uint32_t.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the hash value of the uint32_t pointed to by intToHash. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intToHashPtr</td><td>Pointer to the integer to be hashed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c9fc51c9f65c44f6c78cdaf101ab0e4"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_HashVoidPointer" ref="a2c9fc51c9f65c44f6c78cdaf101ab0e4" args="(const void *voidToHashPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="le__hashmap_8h.html#a2c9fc51c9f65c44f6c78cdaf101ab0e4">le_hashmap_HashVoidPointer</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>voidToHashPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer hashing function. Can be used as a parameter to <a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is an pointer or reference. Simply pass in the address as the key.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the hash value of the pointer pointed to by voidToHashPtr </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">voidToHashPtr</td><td>Pointer to be hashed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5530fc9656f5e49f891541900bc21f34"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_isEmpty" ref="a5530fc9656f5e49f891541900bc21f34" args="(le_hashmap_Ref_t mapRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__hashmap_8h.html#a5530fc9656f5e49f891541900bc21f34">le_hashmap_isEmpty</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tests if the HashMap is empty (i.e. contains zero keys).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if empty, false otherwise. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a853082500b05e57d899606cfc0e34fab"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_MakeTraceable" ref="a853082500b05e57d899606cfc0e34fab" args="(le_hashmap_Ref_t mapRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__hashmap_8h.html#a853082500b05e57d899606cfc0e34fab">le_hashmap_MakeTraceable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes a particular hashmap traceable without enabling the tracing. After this is called, when the trace keyword for this hashmap (the hashmap's name) is enabled for the "framework" component in the process, tracing will start. If that keyword was enabled before this function was called, tracing will start immediately when it is called. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a601b7d3e5d92e91e4090d726e5b190ca"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_NextNode" ref="a601b7d3e5d92e91e4090d726e5b190ca" args="(le_hashmap_It_Ref_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Moves the iterator to the next key/value pair in the map. Order is dependent on the hash algorithm and the order of inserts, and is not sorted at all. If the hashmap is modified during iteration, this function will return an error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns LE_OK unless you go past the end of the map, then returns LE_NOT_FOUND. If the iterator has been invalidated by the map changing or you have previously received a LE_NOT_FOUND then this returns LE_FAULT </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68759fb8291c487a507eae6d92710fc7"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_Put" ref="a68759fb8291c487a507eae6d92710fc7" args="(le_hashmap_Ref_t mapRef, const void *keyPtr, const void *valuePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="le__hashmap_8h.html#a68759fb8291c487a507eae6d92710fc7">le_hashmap_Put</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>keyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>valuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a key-value pair to a HashMap. If the key already exists in the map, the previous value will be replaced with the new value passed into this function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns NULL for a new entry or a pointer to the old value if it is replaced. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valuePtr</td><td>Pointer to the value to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64eab4c096da5b66aa54c70ec5d5a776"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_Remove" ref="a64eab4c096da5b66aa54c70ec5d5a776" args="(le_hashmap_Ref_t mapRef, const void *keyPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="le__hashmap_8h.html#a64eab4c096da5b66aa54c70ec5d5a776">le_hashmap_Remove</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>keyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove a value from a HashMap.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the value or NULL if the key is not found. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27e3af23871a2f9e8adffb748111aab2"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_RemoveAll" ref="a27e3af23871a2f9e8adffb748111aab2" args="(le_hashmap_Ref_t mapRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__hashmap_8h.html#a27e3af23871a2f9e8adffb748111aab2">le_hashmap_RemoveAll</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes all the entries held in the hashmap. This will not delete the data pointed to by the key and value pointers. That cleanup is the responsibility of the caller. This allows the map to be re-used. Currently maps can't be deleted. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a481e3fa6b0fe8319074140a2cb2ae1cc"></a><!-- doxytag: member="le_hashmap.h::le_hashmap_Size" ref="a481e3fa6b0fe8319074140a2cb2ae1cc" args="(le_hashmap_Ref_t mapRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="le__hashmap_8h.html#a481e3fa6b0fe8319074140a2cb2ae1cc">le_hashmap_Size</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the number of keys in the HashMap.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of keys in the HashMap. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="le__hashmap_8h.html">le_hashmap.h</a>      </li>
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless 2014
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.7.6.1
        </div>
    </div>
</body>
</html>
