<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Legato: C Language Coding Standards</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

<link rel="icon" type="image/png" href="favicon.ico">
</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo">
    <img alt="Logo" src="legatoLogo.png"/>
    <div id="projectbrief">Wireless M2M smooth and connected</div>
  </td>
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('ccoding_stds_main.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">C Language Coding Standards </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="ccoding_stds_main.html#cstdsCyclomatic">Cyclomatic Complexity</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsFanOut">Fan Out</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsRecursion">Recursion</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsGotos">Gotos</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsGlobalVariables">Global Variables</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsExtern">Extern</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsHeap">Heap</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsMultipleInclusionGuards">Multiple Inclusion Guards</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsLineLength">Line Length</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsExistingCode">Existing Code</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsNaming">Naming</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsPrefixesOverview">Prefixes Overview</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsInterComponentInterfaces">Component Interfaces</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsInterModuleInterfaces">Module Interfaces</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsFiles">Files</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsMacros">Macros</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsNameSuffix">Suffix Name</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsNamePrefix">Name Prefix</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsNameType">Name Type</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsCardinalTypes">Cardinal Types</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsEnumerationMembers">Enumeration Members</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsStructandUnionNamespaces">Struct and Union Namespaces</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsStructandUnionMembers">Struct and Union Members</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsPrefix">Prefix</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsCamelCaseName">Camel Case Name</a> <br/>
 <a class="el" href="ccoding_stds_main.html#cstdsVerbage">Verbage</a> <br/>
</p>
<p>Other C standards pages:</p>
<p><a class="el" href="c_standards_abbreviations.html">C Standard Abbreviations</a> <br/>
 <a class="el" href="c_standards_parameters.html">C Standard Parameters</a></p>
<h2><a class="anchor" id="cstdsCyclomatic"></a>
Cyclomatic Complexity</h2>
<p><a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity/Cyclomatic">http://en.wikipedia.org/wiki/Cyclomatic_complexity/Cyclomatic</a> complexity is a measurement of the complexity of code within a function. It's measured by counting branches within a function.</p>
<p>Each function gets a starting value of 1, and 1 is added for every "if" (or "?"), every loop (for, do, or while), and every "case".</p>
<p>For example, the following code has a cyclomatic complexity of 3:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)
{
    <span class="keywordtype">int</span> i;
    <span class="keywordtype">int</span> result = 0;

    <span class="keywordflow">if</span> (argc &lt;= 0)
    {
        printf(<span class="stringliteral">&quot;No arguments provided.\n&quot;</span>);
        result = 1;
    }
    <span class="keywordflow">else</span>
    {
        printf(<span class="stringliteral">&quot;argc = %d\n&quot;</span>, argc);

        <span class="keywordflow">for</span> (i = 0; i &lt; argc; i++)
        {
            printf(<span class="stringliteral">&quot;argv[%d] = &#39;%s&#39;\n&quot;</span>, argv[i]);
        }
    }
    <span class="keywordflow">return</span> result;
}
</pre></div><p>Higher levels of cyclomatic complexity are correlated with higher defect density.</p>
<p>All functions should have a cyclomatic complexity of 10 or less.</p>
<p>All functions must have a cyclomatic complexity of less than 15.</p>
<h2><a class="anchor" id="cstdsFanOut"></a>
Fan Out</h2>
<p>Fan-out is a measurement of the number of different functions that are called by a given function, plus the number of data structures that it updates. High levels of fan-out are indicative of insufficient abstraction and are correlated with higher defect density.</p>
<p>For example, the following function has a fan-out of 5: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">int</span> Log(<span class="keywordtype">int</span> value)
{
    <span class="keywordflow">if</span> (IsAboveThreshold(value))
    {
        LogEntry_t* entryPtr = AllocEntry();
        <span class="keywordflow">if</span> (entryPtr == NULL)
        {
            ReportError(<span class="stringliteral">&quot;Out of memory!&quot;</span>);
        }
        <span class="keywordflow">else</span>
        {
            entryPtr-&gt;value = value;
            entryPtr-&gt;timestamp = GetTimestamp();

            <span class="comment">// Add the entry to the log entry list.</span>
            LogEntryList[NextEntryIndex++] = entryPtr;
            <span class="keywordflow">if</span> (NextExtryIndex &gt;= LOG_SIZE)
            {
                NextEntryIndex = 0; <span class="comment">// wrap around</span>
            }
            <span class="keywordflow">if</span> (NextEntryIndex == LastEntryIndex)
            {
                ReportError(<span class="stringliteral">&quot;Log overflow! Log entry discarded.&quot;</span>);
                LastEntryIndex = (LastEntryIndex + 1) % LOG_SIZE;
            }
        }
    }
}
</pre></div><p>The functions IsAboveThreshold(), AllocEntry(), ReportError(), and GetTimestamp() are called by the Log() function. In addition, the "Log" data structure (consisting of the variables LogEntryList, NextEntryIndex, and LastEntryIndex) is updated by the Log() function. Note that the second and subsequent calls to the same function are not counted. So, even though ReportError() is called twice by Log(), it only contributes 1 to the fan-out.</p>
<p>Ideally, fan-out should be kept to 7 or less.</p>
<p>Fan-out must be kept to 10 or less.</p>
<h2><a class="anchor" id="cstdsRecursion"></a>
Recursion</h2>
<p>Recursion can be dangerous because it can result in stack overruns. Don't use recursion, unless you can clearly highlight the recursion and prove to the reader of your code that the recursion will be bounded well within the limits of even the smallest stack space that could reasonably be allocated to your thread.</p>
<h2><a class="anchor" id="cstdsGotos"></a>
Gotos</h2>
<p><b>goto</b> statements should not be used. If they are used, they must be used sparingly as a jump-to-exception-handling mechanism.</p>
<div class="fragment"><pre class="fragment">{
    Rec_t* recPtr = CreateRec();

    ...

    <span class="keywordflow">if</span> (x &gt; LIMIT)
    {
        <span class="keywordflow">goto</span> fault;
    }

    ...

    SaveRec(recPtr);
    <span class="keywordflow">return</span> SUCCESS;

fault:

    ReleaseRec(recPtr);
    <span class="keywordflow">return</span> FAILED;
}
</pre></div><h2><a class="anchor" id="cstdsGlobalVariables"></a>
Global Variables</h2>
<p>Global variables are variables that are exported to other modules (i.e., have a scope that spans multiple files).</p>
<p>Global variables are dangerous because:</p>
<p>they don't allow protections from multithreaded race conditions, they reduce maintainability by increasing coupling.</p>
<p>Globals must not be used. Use accessor functions instead.</p>
<p>NOTE: file-scope static variables are fine.</p>
<h2><a class="anchor" id="cstdsExtern"></a>
Extern</h2>
<p>When global variables are not used and all inter-module interfaces are defined in header files, the "extern" keyword is not needed. Don't use it. Use of "extern" is an indication of poor coding practices.</p>
<h2><a class="anchor" id="cstdsHeap"></a>
Heap</h2>
<p>Depending on the algorithm used, dynamic memory allocation using a memory heap (i.e., using malloc, free, and variants of malloc, such as calloc, realloc, and strdup) can lead to heap fragmentation, resulting in unexpected runtime failures. Furthermore, heap allocation and deallocation can be very slow in some cases.</p>
<p>Use memory pools instead. Memory pools eliminate internal fragmentation, run in O(1) time (for both allocation and deallocation), can be named for diagnostics purposes, allow finer-grained memory allocation statistics collection, and can provide OO constructor and destructor functionality.</p>
<h2><a class="anchor" id="cstdsMultipleInclusionGuards"></a>
Multiple Inclusion Guards</h2>
<p>In order to prevent multiple declaration errors due to multiple inclusion of the same header file, every header file must include a "multiple inclusion guard" of this form:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifndef UNIQUE_INCLUDE_GUARD</span>
<span class="preprocessor"></span><span class="preprocessor">#define UNIQUE_INCLUDE_GUARD</span>
<span class="preprocessor"></span>
...

#endif
</pre></div><p>"UNIQUE_INCLUDE_GUARD" must be replaced with a macro name that is certain to be unique to this header file. To ensure this uniqueness, the macro name should</p>
<ul>
<li>contain the name of the file (converted to all upper case, with underscores separating words),</li>
<li>be prefixed with a name or abbreviation that is unique to the module that the header file is a part of,<ul>
<li>have "_INCLUDE_GUARD" as a suffix.</li>
</ul>
</li>
</ul>
<p>For example, the "Converter" module's inter-module interface file "'''converter.h'''" in the Sierra Wireless ('''SWI''') "'''Transmogrifier'''" component could contain a multiple inclusion guard macro named like this: </p>
<div class="fragment"><pre class="fragment">SWI_TMOG_CONVERTER_INCLUDE_GUARD
</pre></div><p>No code (other than comments) in a header file may reside outside of that file's multiple inclusion guard.</p>
<p>For example, </p>
<div class="fragment"><pre class="fragment"><span class="comment">// Only comments allowed here.</span>

<span class="preprocessor">#ifndef SWI_TMOG_CONVERTER_INCLUDE_GUARD</span>
<span class="preprocessor"></span><span class="preprocessor">#define SWI_TMOG_CONVERTER_INCLUDE_GUARD</span>
<span class="preprocessor"></span>
<span class="comment">// Any code can go here.</span>

<span class="preprocessor">#endif // SWI_TMOG_CONVERTER_INCLUDE_GUARD</span>
<span class="preprocessor"></span>
<span class="comment">// Only comments allowed here, but preferably nothing but the end of file should be here.</span>
</pre></div><p>To allow these include guard macros to be renamed (in case the file is renamed, the code changes hands, a naming conflict is found, etc.) and to avoid confusing future maintainers, these macros should not be used for anything else other than the multiple inclusion guard.</p>
<p>NOTE: when modifying pre-existing code that contains multiple-inclusion guards, use the multiple-inclusion guard style of the pre-existing code, rather than using our style of multiple-inclusion guard.</p>
<h2><a class="anchor" id="cstdsLineLength"></a>
Line Length</h2>
<p>Lines of code should not be longer than 100 columns.</p>
<h2><a class="anchor" id="cstdsExistingCode"></a>
Existing Code</h2>
<p>When modifying pre-existing code, the style of the pre-existing code should be used over any of the standards listed below. However, even when modifying pre-existing code, the '''standards listed above still apply''' to those parts that you modify. Although, you would not be expected to rewrite a complex pre-existing function just because you made a very small change to it.</p>
<h2><a class="anchor" id="cstdsNaming"></a>
Naming</h2>
<p>Naming is arguably one of the most important aspects of coding. The impact that naming has on readability (and therefore reviewability and maintainability) cannot be understated. Extra time spent on choosing the right names or correcting poor naming is almost certainly going to pay back several times over in future savings of time and effort in peer reviews, testing, troubleshooting, and renovations (refactoring, re-engineering, and design and implementation of new requirements).</p>
<p><b>Be Descriptive</b></p>
<p>The most important requirement for names of identifiers, files, etc. is that they '''describe what they are'''. Don't call a pointer to a timer "p", or "tp" (is that toilet paper?). Call it "timerPtr". At a glance, it's extremely obvious what a "timerPtr" is.</p>
<p>It is, however, acceptable for loop counters to be numbered simply "i" (or "j" for a nested loop, or "k" for a nested nested loop), because these are common usages, not only in programming, but also in mathematics.</p>
<p>It is also acceptable for variables with ''very'' limited scope (i.e., limited to a handful of lines of code) to have very simplified names, if that improves readability through the reduction of clutter. For example, "t" becomes more acceptable for a timer reference if it's used in a tiny code block like this: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> StartTimer(<span class="keywordtype">void</span>)
{
    <a class="code" href="le__timer_8h.html#a763fa6992488cdce3b5a820817094838">le_timer_Ref_t</a> t = <a class="code" href="le__timer_8h.html#aee41169a210378b369f440cf99146522">le_timer_Create</a>(TimerPool);
    <a class="code" href="le__timer_8h.html#a0a103d5cef5e83fc9088859d527bbd43">le_timer_SetInterval</a>(t, TIMER_INTERVAL);
    le_timer_SetExpiryHandler(t, TimerExpired, NULL);
    <a class="code" href="le__timer_8h.html#ada2ce7f8cb1e76ed959e323ae94bbfc0">le_timer_Start</a>(t);
}
</pre></div><h2><a class="anchor" id="cstdsPrefixesOverview"></a>
Prefixes Overview</h2>
<p>Often, an identifier prefix is needed to prevent naming conflicts between identifiers that are exported to other modules as a part of an interface. For example, two interfaces may each define a function called "GetSize". To prevent naming conflicts (and to avoid programmer confusion), each of those interfaces prefixes its "GetSize" function identifier with its own, unique prefix. Of course, these prefixes are also needed for other things besides functions: types, variables, files, and macros. This section defines the general structure of these prefixes, while other sections define the specific prefixing rules for types, variables, functions, etc.</p>
<p>The structure of an interface-specific prefix differs based on the scope of the interface. The possible scopes are:</p>
<p>''inter-component'' - an interface implemented by one component and used by other components ''inter-module'' - and interface implemented by one module and used by other modules ''within the same component''.</p>
<p>Note that inter-module interfaces could also be called ''intra''-component interfaces, but "intra" looks and sounds too much like "inter", so "inter-module" is the preferred term.</p>
<p>Each part of the prefix '''must start with a lower case letter''' (unless it is a [[#Macros|macro]] prefix) and must be '''separated from other parts of the identifier using underscores'''.</p>
<p>Underscores are used instead of capitalization to separate the parts of the prefix and to separate the prefix from the identifier for several reasons:</p>
<p>To make the prefix visibly stand out clearly from the rest of the identifier. Because abbreviations tend to often be acronyms, which sometimes get capitalized improperly when using camel case. To make machine parsing of these identifiers easier.</p>
<h2><a class="anchor" id="cstdsInterComponentInterfaces"></a>
Component Interfaces</h2>
<p>'''Inter-component interfaces''' have prefixes containing at least two parts:</p>
<p>company abbreviation interface name abbreviation</p>
<p>The '''company abbreviation''' indicates what company the interface belongs to. For interfaces owned by Sierra Wireless, this could be "swi". For open-source projects, the abbreviation would indicate which project the interface belongs to. For example, interfaces defined as part of the "Legato" project could start with "le_".</p>
<p>The '''interface name abbreviation''' is simply an abbreviation of the interface's name. For example, a "memory management API" might have "mem" as its abbreviation. This abbreviation should not be longer than 5 characters. Two to four characters is preferred.</p>
<p>So, for example, a timer API owned by Sierra Wireless might have the prefix "swi_tmr_",</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>swi_tmr* swi_tmr_Ref_t;

swi_tmr_Ref_t swi_tmr_Create(<span class="keywordtype">void</span>);
<span class="keywordtype">void</span> swi_tmr_SetInterval(swi_tmr_Ref_t timer, uint intervalInMs);
<span class="keywordtype">void</span> swi_tmr_Start(swi_tmr_Ref_t timer);
...

while the Legato Memory Management API could have the prefix <span class="stringliteral">&quot;le_mem_&quot;</span>.


typedef <span class="keyword">struct </span>le_mem_Pool* <a class="code" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>;

le_mem_PoolRef_t <a class="code" href="le__mem_8h.html#afc7288e04f1afff41a83a4da974726ab">le_mem_CreatePool</a>(<span class="keywordtype">size_t</span> blockSizeInBytes);
</pre></div><h2><a class="anchor" id="cstdsInterModuleInterfaces"></a>
Module Interfaces</h2>
<p>'''Inter-module interfaces''' have only one part to their prefix: an interface name abbreviation. For example, a "Registration List" module may use the prefix "rlist_", while a "Registration" module, which implements the Registration objects that get stored in the Registration List might use the prefix "reg_":</p>
<p>void rlist_Add(reg_Ref_t registration); void rlist_Remove(reg_Ref_t registration); reg_Ref_t rlist_FindByName(const char* name);</p>
<p>Because inter-module interfaces are not seen outside of the component in which they are defined, it is impossible to have a naming conflict between an inter-module interface in one component and an inter-module interface in another component (Actually, there could still be a conflict at the link stage, if the symbols are allowed to leak out, but a linker script file can be used to prevent this quite easily). Furthermore, because all interfaces imported from outside a component will have both a company prefix and an interface name abbreviation, it is impossible to have a naming conflict between an inter-component interface and an inter-module interface. The difference in the prefixes also highlights the scope differences of the identifiers, which can be significant to those who have to read the code someday: someone looking at a piece of code can easily see whether there is coupling with other components or just other modules within the same component.</p>
<h2><a class="anchor" id="cstdsFiles"></a>
Files</h2>
<p>As with other forms of identifiers, the most important requirement for file names is that they '''must be descriptive'''. I.e., the name of the file must clearly describe what the file contains.</p>
<p>Also important, however, is that files must be named in such a way that their '''names will not conflict''' with the names of other files. This is mainly important for include files. For example, don't call one of your header files "time.h", because that name will conflict with the C standard library file of the same name. To this end, '''inter-component interface''' headers must be prefixed with the '''company abbreviation''' [[#CompanyAbbreviation|as described above]]. (For example, the Sierra Wireless "Transmogrifier" API include file could be named something like "swi_transmog.h".) But, prefixes are not required on files that are only visible within a limited scope (e.g., implementation files or inter-module interfaces only visible inside a single software component).</p>
<h2><a class="anchor" id="cstdsMacros"></a>
Macros</h2>
<p>Macros can be used in similar ways to variables and functions, but their behaviour has subtle differences that can result in bugs or code bloat if used incorrectly. Compiler errors and warnings resulting from macro substitution can also be somewhat cryptic and difficult to understand if it isn't obvious that the code involved is a macro. Therefore, it is important to be able to easily distinguish visually a macro from a non-macro when reading code. To this end, macro names must be '''all uppercase''', with words separated using '''underscores'''.</p>
<p>Names of macros can also conflict with the names of macros defined in include files from other modules. To reduce the chances of a naming conflict, any '''macros exported to other modules must have a prefix''', and even macros only used within a single file should have a prefix if the names are likely to conflict with names defined in standard C libraries and other included code that doesn't use prefixes. Prefix rules are [[#Prefixes|defined above]].</p>
<h2><a class="anchor" id="cstdsNameSuffix"></a>
Suffix Name</h2>
<p>Types are distinctly different from instances, and yet it is possible to name them such that it can be hard to tell whether something is a type or a variable when reading the code. And naming conflicts can occur between types and variables and even between types and functions. To prevent these sorts of issues, type names are always given an '''"_t" suffix'''.</p>
<h2><a class="anchor" id="cstdsNamePrefix"></a>
Name Prefix</h2>
<p>If a type is defined in a header file, there's the possibility that its name may conflict with the name of another type defined elsewhere. To prevent such conflicts, all types that are defined '''inside header files must have a prefix'''</p>
<p>Types that are defined inside implementation (.c) files don't need such a prefix. They have file scope, and imported types will have prefixes, so naming conflicts are highly unlikely.</p>
<p>The prefix (if any) must be all lower-case.</p>
<h2><a class="anchor" id="cstdsNameType"></a>
Name Type</h2>
<p>After the prefix (if any), the rest of the type name must be in CamelCase, beginning with an uppercase character. </p>
<div class="fragment"><pre class="fragment"><span class="comment">// Inside a .c file:</span>
<span class="keyword">typedef</span> <span class="keywordtype">size_t</span> ObjectCount_t;



<span class="comment">// Inside the Sierra Wireless &quot;Foo&quot; component&#39;s API .h file:</span>
<span class="keyword">typedef</span> <span class="keywordtype">size_t</span> swi_foo_ObjectCount_t;
</pre></div><h2><a class="anchor" id="cstdsCardinalTypes"></a>
Cardinal Types</h2>
<p>Cardinal types (e.g., int, uint, int32, bool) are exempt from having a prefix or suffix because</p>
<p>a. naming a variable "bool" or "int" would not be very descriptive, so there's little point in trying to avoid such naming conflicts. a. most cardinal types are built into the language and we are not allowed to change their names (nor would we want to -- imagine the confusion and the 3rd-party integration problems!).</p>
<h2><a class="anchor" id="cstdsEnumerationMembers"></a>
Enumeration Members</h2>
<p>Enumeration members are constants that are used in a very similar way to macro constants. To clearly identify them as literal constants, they must be named using '''all upper-case with underscores separating words'''.</p>
<p>Also like macros, names of enumeration members can also conflict with the names of macros and enumeration members defined in include files from other modules. To reduce the chances of a naming conflict, any '''members of enumerations exported to other modules must have a prefix''', and even members of enumerations only used within a single file should have a prefix if the names are likely to conflict with names defined in standard C libraries and other included code that doesn't use prefixes.</p>
<h2><a class="anchor" id="cstdsStructandUnionNamespaces"></a>
Struct and Union Namespaces</h2>
<p>When a structure or union is defined, it's possible to give a name to that structure or union within a separate namespace. In the following example, "MessageBody" and "Message" are in the union and struct namespaces, but "MessageBody_t" and "Message_t" are not:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">union </span>MessageBody
{
    Request_t request;
    Response_t response;
}
MessageBody_t;

<span class="keyword">typedef</span> <span class="keyword">struct </span>Message
{
    MessageType_t type;
    MessageBody_t body;
}
Message_t;
</pre></div><p>All uses of a name in the struct namespace must be preceded by the keyword "struct". Likewise, all uses of a name in the union namespace must be preceded by the keyword "union". Because these identifiers always appear with "struct" or "union" right before them, there is no confusion as to whether they are types, variables or functions; and because they are in a separate namespace, there's no possibility of naming conflicts with identifiers outside of the struct and union namespaces. Therefore, these names are '''exempt from having an "_t" suffix'''. However, if these are defined in a header file, they still must have a prefix to prevent naming conflicts with other identifiers defined by other components in the same namespace.</p>
<h2><a class="anchor" id="cstdsStructandUnionMembers"></a>
Struct and Union Members</h2>
<p>The names of members of structures and unions must start with a lower-case letter and use camel case to separate words.</p>
<p>Because structure and union member names are always used in context (in a dereference expression), there is no confusing them with other types' members (assuming the structure or union reference identifier is well named). Therefore, no prefix is needed on structure or union member names.</p>
<p>For example, </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct</span>
{
    <span class="keywordtype">char</span>* textBufferPtr;
    <span class="keywordtype">int</span>   textLength;

    ...
}
MyStructure_t;

<span class="keyword">static</span> <span class="keywordtype">void</span> PrintTextBuffer(MyStructure_t* objectPtr)
{
    <span class="keywordtype">int</span> i;
    <span class="keywordflow">for</span> (i = 0; i &lt; objectPtr-&gt;textLength; i++)
    {
        PrintChar(objectPtr-&gt;textBufferPtr[i]);
    }
}
</pre></div><p> Note: Only stack variable names and struct/union member names can (and must) start with lower-case letters.</p>
<h2><a class="anchor" id="cstdsPrefix"></a>
Prefix</h2>
<p>If a function is defined in a header file, there's the possibility that its name may conflict with the name of another function defined elsewhere. To prevent such conflicts, all functions defined '''inside header files must have a prefix'''</p>
<p>Functions that are defined inside implementation (.c) files don't need an inter-component or inter-module prefix. Functions defined inside .c files have file scope and any imported functions will have inter-component or inter-module prefixes, so naming conflicts are highly unlikely.</p>
<p>In addition, if a function belongs to a specific type of object (i.e., class) in an object oriented interface, its prefix must have an additional object name part. The object name part of a prefix must start with a lowercase letter and must be separated from other parts of the identifier using underscores. If the object name is made up of multiple words, they must be separated using capitalization of the first letter of the second and subsequent words in the object name (e.g., ipRoute or simCard).</p>
<div class="fragment"><pre class="fragment">pool = <a class="code" href="le__mem_8h.html#afc7288e04f1afff41a83a4da974726ab">le_mem_CreatePool</a>(<span class="keyword">sizeof</span>(MyObject_t), <span class="stringliteral">&quot;My objects&quot;</span>);  <span class="comment">// This function doesn&#39;t belong to a class.</span>
le_mem_pool_Expand(pool, numObjects);  <span class="comment">// This is one of the &quot;pool&quot; class&#39;s functions.</span>
objPtr = le_mem_pool_Alloc(pool); <span class="comment">// This also belongs to the &quot;pool&quot; class.</span>
objSize = le_mem_block_GetSize(objPtr);  <span class="comment">// This function belongs to the &quot;block&quot; class.</span>
</pre></div><h2><a class="anchor" id="cstdsCamelCaseName"></a>
Camel Case Name</h2>
<p>After the prefix (if any), the rest of the function name should be in CamelCase, starting with an uppercase letter.</p>
<h2><a class="anchor" id="cstdsVerbage"></a>
Verbage</h2>
<p>Function names '''must contain a verb''', because they are active. They should also contain an object, unless the object is obvious in the prefix.</p>
<p>To be consistent with Java conventions, the '''verb should come before the object'''.</p>
<p>Examples are:</p>
<div class="fragment"><pre class="fragment">GetTimeRemaining(), <a class="code" href="le__mem_8h.html#afc7288e04f1afff41a83a4da974726ab">le_mem_CreatePool</a>(), and swi_timer_Start().
</pre></div><hr/>
<p>Copyright (C) Sierra Wireless, Inc. 2014. All rights reserved. Use of this work is subject to license. </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless 2014
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.7.6.1
        </div>
    </div>
</body>
</html>
