<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Legato: interfaces/config/c/le_cfg_interface.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

<link rel="icon" type="image/png" href="favicon.ico">
</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo">
    <img alt="Logo" src="legatoLogo.png"/>
    <div id="projectbrief">Wireless M2M smooth and connected</div>
  </td>
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('le__cfg__interface_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">interfaces/config/c/le_cfg_interface.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="legato_8h_source.html">legato.h</a>&quot;</code><br/>
<code>#include &quot;configTypes.h&quot;</code><br/>
</div>
<p><a href="le__cfg__interface_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affe352cba8a8cac1f8950901ea47b61c"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_ChangeHandlerFunc_t" ref="affe352cba8a8cac1f8950901ea47b61c" args=")(void *contextPtr)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>le_cfg_ChangeHandlerFunc_t</b> )(void *contextPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad02e652d8ea74b6e8ebb8125190e5244"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_ChangeHandlerRef_t" ref="ad02e652d8ea74b6e8ebb8125190e5244" args="" -->
typedef struct <br class="typebreak"/>
le_cfg_ChangeHandler *&#160;</td><td class="memItemRight" valign="bottom"><b>le_cfg_ChangeHandlerRef_t</b></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a5228a4832c56fbec5a6448db814d6a49">le_cfg_StartClient</a> (const char *serviceInstanceName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a04d4fcfe495fe8ff73e7b1bfe9a034a0">le_cfg_StopClient</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">le_cfg_iteratorRef_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ae7a92fa69f5708e927e542e98e52caee">le_cfg_CreateReadTxn</a> (const char *basePath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">le_cfg_iteratorRef_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ab159b23a0ae8198914341df64f1c9045">le_cfg_CreateWriteTxn</a> (const char *basePath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a89537db8a8ed10affb2c70dd22f7539f">le_cfg_CommitWrite</a> (le_cfg_iteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#af68a7cfcc4ca9a2bffeb5cbe239a3ed5">le_cfg_DeleteIterator</a> (le_cfg_iteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a2a64d24a204a4d897829f17a2dadeea4">le_cfg_GoToNode</a> (le_cfg_iteratorRef_t iteratorRef, const char *newPath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aa0551224f1b8b8155dcf6886488082a1">le_cfg_GoToParent</a> (le_cfg_iteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ab12f4606d720f53b22fe8af7938d397a">le_cfg_GoToFirstChild</a> (le_cfg_iteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a445a41f21155ef62c5a61e0d047b548b">le_cfg_GoToNextSibling</a> (le_cfg_iteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a8232c8d243a496ddb77d5374eef4b833">le_cfg_IsWriteable</a> (le_cfg_iteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a8e550b94d2ca7b9fc94dcfb984109353">le_cfg_IsValid</a> (le_cfg_iteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a6e1076da438f263c67d32288be8de932">le_cfg_GetPath</a> (le_cfg_iteratorRef_t iteratorRef, char *newPath, size_t newPathNumElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a3bb30c400884c4ad65cb06f4bc68561b">le_cfg_GetParentPath</a> (le_cfg_iteratorRef_t iteratorRef, char *newPath, size_t newPathNumElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">le_cfg_nodeType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a9852602d07166ef3f042d5b53bcc7d83">le_cfg_GetNodeType</a> (le_cfg_iteratorRef_t iteratorRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a4bd09e23c40023688adb94677723765b">le_cfg_GetNodeName</a> (le_cfg_iteratorRef_t iteratorRef, char *name, size_t nameNumElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">le_cfg_ChangeHandlerRef_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aa9a19e022625fc2c4a2a39e95ac60936">le_cfg_AddChangeHandler</a> (const char *newPath, le_cfg_ChangeHandlerFunc_t handlerPtr, void *contextPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a17fa5e63dd1f5a2b7b66c92a76f8c98a">le_cfg_RemoveChangeHandler</a> (le_cfg_ChangeHandlerRef_t addHandlerRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a38adaaff34633212d52c9d27b107c033">le_cfg_QuickDeleteNode</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a5b8666bf095746a92392c6b29cd49540">le_cfg_QuickSetEmpty</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a47297979b85e457b1bd63ee98a258c48">le_cfg_QuickGetString</a> (const char *path, char *value, size_t valueNumElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#af5534a2010b8571c4c635f43eed563fb">le_cfg_QuickSetString</a> (const char *path, const char *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a09cd88b9e713f8ae281c924bba7b292a">le_cfg_QuickGetInt</a> (const char *path, int32_t *valuePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a720ecd8357336f9aca502f2db864d78c">le_cfg_QuickSetInt</a> (const char *path, int32_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a0d29788be36bcc7594b305f8fa3b64a2">le_cfg_QuickGetFloat</a> (const char *path, double *valuePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ac6a9b0cede42cd5ab50b3bda4e7855f1">le_cfg_QuickSetFloat</a> (const char *path, double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a09438c35825ef6512b30d3d311d2dd17">le_cfg_QuickGetBool</a> (const char *path, bool *valuePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#adc0de4dd113e22a163aa9e1c2218c821">le_cfg_QuickSetBool</a> (const char *path, bool value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a69d0a9c08f5a10041b1e05dc01674994">le_cfg_DeleteNode</a> (le_cfg_iteratorRef_t iteratorRef, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ab832235fda53d1b879b764799ef7b2f9">le_cfg_IsEmpty</a> (le_cfg_iteratorRef_t iteratorRef, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a98f4e9c1266082f480834218066b16df">le_cfg_SetEmpty</a> (le_cfg_iteratorRef_t iteratorRef, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#af63c472aa9149b674a83ffa76e995d86">le_cfg_GetString</a> (le_cfg_iteratorRef_t iteratorRef, const char *path, char *value, size_t valueNumElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a5ea101446974df3c6578ed8c4e93b59d">le_cfg_SetString</a> (le_cfg_iteratorRef_t iteratorRef, const char *path, const char *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a323adffc28023748666fac13b8a32706">le_cfg_GetInt</a> (le_cfg_iteratorRef_t iteratorRef, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a65ed6159c4e5f16e10a2eb0475c71f25">le_cfg_SetInt</a> (le_cfg_iteratorRef_t iteratorRef, const char *path, int32_t value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a52cf08724ff1f0745ad094fdaef033e0">le_cfg_GetFloat</a> (le_cfg_iteratorRef_t iteratorRef, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#abcc99ad3f741550ce20b7013111ded50">le_cfg_SetFloat</a> (le_cfg_iteratorRef_t iteratorRef, const char *path, double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ac8bf60b44513b5cfb80d2adcf2e1c499">le_cfg_GetBool</a> (le_cfg_iteratorRef_t iteratorRef, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ac1535ef324bc106ad2442b39ef48bb16">le_cfg_SetBool</a> (le_cfg_iteratorRef_t iteratorRef, const char *path, bool value)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="api_config.html">Configuration Tree API</a></p>
<p>Copyright (C) Sierra Wireless, Inc. 2014. All rights reserved. Use of this work is subject to license. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa9a19e022625fc2c4a2a39e95ac60936"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_AddChangeHandler" ref="aa9a19e022625fc2c4a2a39e95ac60936" args="(const char *newPath, le_cfg_ChangeHandlerFunc_t handlerPtr, void *contextPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">le_cfg_ChangeHandlerRef_t <a class="el" href="le__cfg__interface_8h.html#aa9a19e022625fc2c4a2a39e95ac60936">le_cfg_AddChangeHandler</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">le_cfg_ChangeHandlerFunc_t&#160;</td>
          <td class="paramname"><em>handlerPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>contextPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function adds a handler ... </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newPath</td><td>Path to the object to watch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89537db8a8ed10affb2c70dd22f7539f"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_CommitWrite" ref="a89537db8a8ed10affb2c70dd22f7539f" args="(le_cfg_iteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a89537db8a8ed10affb2c70dd22f7539f">le_cfg_CommitWrite</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the write iterator and commit the write transaction. This updates the config tree with all of the writes that occured using the iterator.</p>
<p>If the transaction had timed out, or if the iterator has been moved out of bounds, the commit will fail.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>: This operation will also delete the iterator object so you don't have to call DeleteIterator.</dd>
<dd>
: All clones of this iterator also have to commit their write transactions before the transaction is actually comitted to the tree.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return one of the following:</dd></dl>
<ul>
<li>LE_OK - Commit was completed successfuly.</li>
<li>LE_BAD_PARAMETER - Attempted an invalid iterator for this request.</li>
<li>LE_NOT_PERMITTED - Attempted an iterator that has been moved out of bounds.</li>
<li>LE_TIMEOUT - Transaction had timed out.</li>
<li>LE_CLOSED - Transaction was canceled by one of the clones of this iterator. Nothing has been committed.</li>
<li>LE_WOULD_BLOCK - Data has been committed to the parent transaction, but other iterators of this transaction are still outstanding. This data will only be comitted to the live tree when all clones have been comitted successfuly. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to commit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7a92fa69f5708e927e542e98e52caee"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_CreateReadTxn" ref="ae7a92fa69f5708e927e542e98e52caee" args="(const char *basePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">le_cfg_iteratorRef_t <a class="el" href="le__cfg__interface_8h.html#ae7a92fa69f5708e927e542e98e52caee">le_cfg_CreateReadTxn</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a read transaction and open a new iterator for traversing the configuration tree.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>: This action creates a read transaction that will exist for the lifetime of all active iterators. If the application holds the iterator for longer than the configured read transaction timeout, active iterators will become invalid and no longer return data.</dd>
<dd>
: A tree transaction is global; a long held read transaction will block other users write transactions from being comitted. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basePath</td><td>Path to the location to create the new iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab159b23a0ae8198914341df64f1c9045"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_CreateWriteTxn" ref="ab159b23a0ae8198914341df64f1c9045" args="(const char *basePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">le_cfg_iteratorRef_t <a class="el" href="le__cfg__interface_8h.html#ab159b23a0ae8198914341df64f1c9045">le_cfg_CreateWriteTxn</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a write transaction and open a new iterator for both reading and writing. &amp; </p>
<dl class="note"><dt><b>Note:</b></dt><dd>: This action creates a write transaction. If the application holds the iterator for longer than the configured write transaction timeout, the iterator will cancel the transaction. All further reads will fail to return data and all writes will be thrown away.</dd>
<dd>
A tree transaction is global, so a long held read transaction will block other user's write transactions from being comitted. However other trees in the system will be unaffected.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This will return a newly created iterator reference. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basePath</td><td>Path to the location to create the new iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af68a7cfcc4ca9a2bffeb5cbe239a3ed5"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_DeleteIterator" ref="af68a7cfcc4ca9a2bffeb5cbe239a3ed5" args="(le_cfg_iteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#af68a7cfcc4ca9a2bffeb5cbe239a3ed5">le_cfg_DeleteIterator</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close and free the given iterator object. If the iterator is a write iterator, the transaction will be canceled. If the iterator is a read iterator, the transaction will be closed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69d0a9c08f5a10041b1e05dc01674994"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_DeleteNode" ref="a69d0a9c08f5a10041b1e05dc01674994" args="(le_cfg_iteratorRef_t iteratorRef, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a69d0a9c08f5a10041b1e05dc01674994">le_cfg_DeleteNode</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete the leaf or stem specified by the path. If the node doesn't exist, nothing happens. All child nodes are also deleted.</p>
<p>If the path is empty, the iterator's current node is deleted.</p>
<p>Only valid during a write transaction.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the iterator is invalid, or it's not writeable, this request will be ignored. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Absolute or relative path to the node to delete. If Absolute path is given, it is rooted off of the user's root node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8bf60b44513b5cfb80d2adcf2e1c499"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetBool" ref="ac8bf60b44513b5cfb80d2adcf2e1c499" args="(le_cfg_iteratorRef_t iteratorRef, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__cfg__interface_8h.html#ac8bf60b44513b5cfb80d2adcf2e1c499">le_cfg_GetBool</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a value from the tree as a boolean. Empty values are considered false, non-zero values are considered true.</p>
<p>If the value is a non-empty string, a true is returned, false otherwise. If the value is a number and non-zero, a true is returned, false otherwise.</p>
<p>Valid for both read and write transactions.</p>
<p>If the path is empty, then the iterator's current node will be read.</p>
<p>If the iterator is invalid, or the value is empty, a false is returned. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Full or relative path to the value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52cf08724ff1f0745ad094fdaef033e0"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetFloat" ref="a52cf08724ff1f0745ad094fdaef033e0" args="(le_cfg_iteratorRef_t iteratorRef, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="le__cfg__interface_8h.html#a52cf08724ff1f0745ad094fdaef033e0">le_cfg_GetFloat</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a 64-bit floating point value from the configuration tree. If the underlying value is not a float, it will be converted.</p>
<p>If the value is an int, then a straight conversion will be performed. Bool values will be read as either a floating point, 0 or 1. Strings and empty values are read as 0.0.</p>
<p>If the path is empty, the iterator's current node will be read.</p>
<p>If the iterator is invalid, or the value is empty, a 0.0 is returned. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Full or relative path to the value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a323adffc28023748666fac13b8a32706"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetInt" ref="a323adffc28023748666fac13b8a32706" args="(le_cfg_iteratorRef_t iteratorRef, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="le__cfg__interface_8h.html#a323adffc28023748666fac13b8a32706">le_cfg_GetInt</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a signed integer value from the configuration tree. If the underlying value is not an integer, it will be converted.</p>
<p>If the value is a string, then 0 is returned. If the value is a float, a truncated int is returned. If the value is a bool, a 0 or a 1 is returned.</p>
<p>Valid for both read and write transactions.</p>
<p>If the path is empty, the iterator's current node will be read.</p>
<p>If the iterator is invalid, or the value is empty, a 0 is returned. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Full or relative path to the value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bd09e23c40023688adb94677723765b"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetNodeName" ref="a4bd09e23c40023688adb94677723765b" args="(le_cfg_iteratorRef_t iteratorRef, char *name, size_t nameNumElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a4bd09e23c40023688adb94677723765b">le_cfg_GetNodeName</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nameNumElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the name of the node where the iterator is currently pointing.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Write was completed successfuly.<ul>
<li>LE_OVERFLOW - Supplied string buffer was not large enough to hold the value.</li>
<li>LE_BAD_PARAMETER - Supplied iterator reference was invalid. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to use to read from the tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>Read the name of the node object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nameNumElements</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9852602d07166ef3f042d5b53bcc7d83"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetNodeType" ref="a9852602d07166ef3f042d5b53bcc7d83" args="(le_cfg_iteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">le_cfg_nodeType_t <a class="el" href="le__cfg__interface_8h.html#a9852602d07166ef3f042d5b53bcc7d83">le_cfg_GetNodeType</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the type of node where the iterator is currently pointing.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>le_cfg_nodeType_t value indicating the stored value. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to use to read from the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bb30c400884c4ad65cb06f4bc68561b"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetParentPath" ref="a3bb30c400884c4ad65cb06f4bc68561b" args="(le_cfg_iteratorRef_t iteratorRef, char *newPath, size_t newPathNumElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a3bb30c400884c4ad65cb06f4bc68561b">le_cfg_GetParentPath</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>newPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newPathNumElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the path to the parent of the node where the iterator is currently pointed.</p>
<p>Assuming the following tree:</p>
<div class="fragment"><pre class="fragment">  baseNode/
    childA/
      valueA
      valueB
</pre></div><p>If the iterator was currently pointing at valueB, GetParentPath would return the following path:</p>
<div class="fragment"><pre class="fragment">  /baseNode/childA/
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Write was completed successfuly.<ul>
<li>LE_OVERFLOW - Supplied string buffer was not large enough to hold the value.</li>
<li>LE_BAD_PARAMETER - Supplied iterator reference was invalid. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to move. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newPath</td><td>Absolute path for the parent of the node that the iterator is residing on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPathNumElements</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e1076da438f263c67d32288be8de932"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetPath" ref="a6e1076da438f263c67d32288be8de932" args="(le_cfg_iteratorRef_t iteratorRef, char *newPath, size_t newPathNumElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a6e1076da438f263c67d32288be8de932">le_cfg_GetPath</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>newPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newPathNumElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get path to the node where the iterator is currently pointed.</p>
<p>Assuming the following tree:</p>
<div class="fragment"><pre class="fragment">  baseNode/
    childA/
      valueA
      valueB
</pre></div><p>If the iterator was currently pointing at valueA, GetPath would return the following path:</p>
<div class="fragment"><pre class="fragment">  /baseNode/childA/valueA
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Write was completed successfuly.<ul>
<li>LE_OVERFLOW - Supplied string buffer was not large enough to hold the value.</li>
<li>LE_BAD_PARAMETER - Supplied iterator reference was invalid. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to move. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newPath</td><td>Absolute path to the iterator's current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPathNumElements</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af63c472aa9149b674a83ffa76e995d86"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GetString" ref="af63c472aa9149b674a83ffa76e995d86" args="(le_cfg_iteratorRef_t iteratorRef, const char *path, char *value, size_t valueNumElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#af63c472aa9149b674a83ffa76e995d86">le_cfg_GetString</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valueNumElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a string value from the configuration tree. If the stored value is not a string, the value will be converted into a string.</p>
<p>If the value is a number, a string with that number is returned. If the value is empty, or the iterator is invalid, an empty string is returned. If the value is boolean, the string, "true" or "false" is returned.</p>
<p>Valid for both read and write transactions.</p>
<p>If the path is empty, the iterator's current node will be read.</p>
<p>If the iterator is invalid, an empty string is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Write was completed successfuly.<ul>
<li>LE_OVERFLOW - Supplied string buffer was not large enough to hold the value. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Absolute or relative path to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Buffer to write the value into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueNumElements</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab12f4606d720f53b22fe8af7938d397a"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GoToFirstChild" ref="ab12f4606d720f53b22fe8af7938d397a" args="(le_cfg_iteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#ab12f4606d720f53b22fe8af7938d397a">le_cfg_GoToFirstChild</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the iterator to the the first child of the node where the iterator is currently pointed.</p>
<p>For read iterators without children, this function will fail. If the iterator is a write iterator, then a new node is automatically created. If this node or newly created children of this node are not written to, then this node will not persist even if the iterator is comitted.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return code will be one of the following values:</dd></dl>
<ul>
<li>LE_OK - Move was completed successfuly.</li>
<li>LE_BAD_PARAMETER - Attempted an invalid iterator for this request.</li>
<li>LE_NOT_PERMITTED - Attempted to create a new node on a read iterator. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a445a41f21155ef62c5a61e0d047b548b"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GoToNextSibling" ref="a445a41f21155ef62c5a61e0d047b548b" args="(le_cfg_iteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a445a41f21155ef62c5a61e0d047b548b">le_cfg_GoToNextSibling</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Jump the iterator to the next child node of the current node. Assuming the following tree:</p>
<div class="fragment"><pre class="fragment">  baseNode/
    childA/
      valueA
      valueB
</pre></div><p>If the iterator is moved to the path, "/baseNode/childA/valueA". After the first GoToNextSibling the iterator will be pointing at valueB. A second call to GoToNextSibling will cause the function to return LE_NOT_FOUND.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns one of the following values:</dd></dl>
<ul>
<li>LE_OK - Commit was completed successfuly.</li>
<li>LE_BAD_PARAMETER - Attempted to use an invalid iterator for this request.</li>
<li>LE_NOT_FOUND - Iterator has reached the end of the current list of sub nodes. Also returned if the the current node has no sub items. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to iterate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a64d24a204a4d897829f17a2dadeea4"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GoToNode" ref="a2a64d24a204a4d897829f17a2dadeea4" args="(le_cfg_iteratorRef_t iteratorRef, const char *newPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a2a64d24a204a4d897829f17a2dadeea4">le_cfg_GoToNode</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the stem that the iterator is pointing to. The path passed can be an absolute or a relative path from the iterators current location.</p>
<p>Calling GoToNode with a path of "." will jump the iterator back to the first sub-item of the current stem.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns one of the following values:</dd></dl>
<ul>
<li>LE_OK - Commit was completed successfuly.</li>
<li>LE_BAD_PARAMETER - Attempted an invalid iterator for this request.</li>
<li>LE_NOT_PERMITTED - Attempted the iterator outside of the allowed area (e.g., trying to change trees in an iterator is not permitted).</li>
<li>LE_NOT_POSSIBLE - Could not look up permission information. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to move. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPath</td><td>Absolute or relative path from the current location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0551224f1b8b8155dcf6886488082a1"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_GoToParent" ref="aa0551224f1b8b8155dcf6886488082a1" args="(le_cfg_iteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#aa0551224f1b8b8155dcf6886488082a1">le_cfg_GoToParent</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the iterator to the parent of the node.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return code will be one of the following values:</dd></dl>
<ul>
<li>LE_OK - Commit was completed successfuly.</li>
<li>LE_BAD_PARAMETER - Attempted an invalid iterator for this request.</li>
<li>LE_NOT_PERMITTED - Current node is the root node: has no parent.</li>
<li>LE_NOT_POSSIBLE - Could not look up permission information. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab832235fda53d1b879b764799ef7b2f9"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_IsEmpty" ref="ab832235fda53d1b879b764799ef7b2f9" args="(le_cfg_iteratorRef_t iteratorRef, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__cfg__interface_8h.html#ab832235fda53d1b879b764799ef7b2f9">le_cfg_IsEmpty</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if the given node is empty. A node is also considered empty if it doesn't yet exist.</p>
<p>If the path is empty, the iterator's current node is queried for emptiness.</p>
<p>Valid for both read and write transactions. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Absolute or relative path to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e550b94d2ca7b9fc94dcfb984109353"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_IsValid" ref="a8e550b94d2ca7b9fc94dcfb984109353" args="(le_cfg_iteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__cfg__interface_8h.html#a8e550b94d2ca7b9fc94dcfb984109353">le_cfg_IsValid</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check to see if the iterator reference points to a valid iterator object.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>An iterator is considered no longer valid if one if its clones cancels the underlying transaction.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- true - Object is valid and can be used.<ul>
<li>false - Object is no longer valid either through a security violation or its been cancelled. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8232c8d243a496ddb77d5374eef4b833"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_IsWriteable" ref="a8232c8d243a496ddb77d5374eef4b833" args="(le_cfg_iteratorRef_t iteratorRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="le__cfg__interface_8h.html#a8232c8d243a496ddb77d5374eef4b833">le_cfg_IsWriteable</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check the iterator to see the interator represents a write transaction.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- true - Write transaction object.<ul>
<li>false - Read only transaction object. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38adaaff34633212d52c9d27b107c033"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickDeleteNode" ref="a38adaaff34633212d52c9d27b107c033" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a38adaaff34633212d52c9d27b107c033">le_cfg_QuickDeleteNode</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete the node specified by the path. If the node doesn't exist, nothing happens. All child nodes are also deleted.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Commit was completed successfuly.<ul>
<li>LE_BAD_PARAMETER - Attempted an invalid path for this request.</li>
<li>LE_NOT_PERMITTED - Attempted a path that is out of bounds. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the node to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09438c35825ef6512b30d3d311d2dd17"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickGetBool" ref="a09438c35825ef6512b30d3d311d2dd17" args="(const char *path, bool *valuePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a09438c35825ef6512b30d3d311d2dd17">le_cfg_QuickGetBool</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>valuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a value from the tree as a boolean. Empty values are considered false, non-zero values are considered true.</p>
<p>If the value is a non-empty string, a true is returned, false otherwise. If the value is a number and non-zero, a true is returned, false otherwise.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Commit was completed successfuly.<ul>
<li>LE_BAD_PARAMETER - Attempted an invalid path for this request.</li>
<li>LE_NOT_PERMITTED - Attempted a path that is out of bounds. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">valuePtr</td><td>The value to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d29788be36bcc7594b305f8fa3b64a2"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickGetFloat" ref="a0d29788be36bcc7594b305f8fa3b64a2" args="(const char *path, double *valuePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a0d29788be36bcc7594b305f8fa3b64a2">le_cfg_QuickGetFloat</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>valuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a 64-bit floating point value from the configuration tree. If the underlying value is not a float, it will be converted.</p>
<p>If the value is an int, then a straight conversion will be performed. Bool values will be read as either a floating point, 0 or 1. Strings and empty values are read as 0.0.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Commit was completed successfuly.<ul>
<li>LE_BAD_PARAMETER - Attempted an invalid path for this request.</li>
<li>LE_NOT_PERMITTED - Attempted a path that is out of bounds. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">valuePtr</td><td>Value to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09cd88b9e713f8ae281c924bba7b292a"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickGetInt" ref="a09cd88b9e713f8ae281c924bba7b292a" args="(const char *path, int32_t *valuePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a09cd88b9e713f8ae281c924bba7b292a">le_cfg_QuickGetInt</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a signed integer value from the configuration tree. If the underlying value is not an integer, it will be converted.</p>
<p>If the value is a string, 0 is returned. If the value is a float, a truncated int is returned. If the value is a bool, a 0 or a 1 is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Commit was completed successfuly.<ul>
<li>LE_BAD_PARAMETER - Attempted an invalid path for this request.</li>
<li>LE_NOT_PERMITTED - Attempted a path that is out of bounds. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">valuePtr</td><td>Value to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47297979b85e457b1bd63ee98a258c48"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickGetString" ref="a47297979b85e457b1bd63ee98a258c48" args="(const char *path, char *value, size_t valueNumElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a47297979b85e457b1bd63ee98a258c48">le_cfg_QuickGetString</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valueNumElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a string value from the configuration tree. If the stored value is not a string, the value will be converted into a string.</p>
<p>If the value is a number, a string with that number is returned. If the value is empty, or the iterator is invalid, an empty string is returned. If the value is boolean, the string, "true" or "false" is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Commit was completed successfuly.<ul>
<li>LE_BAD_PARAMETER - Attempted an invalid path for this request.</li>
<li>LE_NOT_PERMITTED - Attempted a path that is out of bounds, or in a tree without necessary access.</li>
<li>LE_OVERFLOW - Supplied string buffer was not large enough to hold the value. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value read from the requested node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueNumElements</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc0de4dd113e22a163aa9e1c2218c821"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickSetBool" ref="adc0de4dd113e22a163aa9e1c2218c821" args="(const char *path, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#adc0de4dd113e22a163aa9e1c2218c821">le_cfg_QuickSetBool</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a boolean value to the configuration tree.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Commit was completed successfuly.<ul>
<li>LE_BAD_PARAMETER - Attempted an invalid path for this request.</li>
<li>LE_NOT_PERMITTED - Attempted a path that is out of bounds. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b8666bf095746a92392c6b29cd49540"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickSetEmpty" ref="a5b8666bf095746a92392c6b29cd49540" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a5b8666bf095746a92392c6b29cd49540">le_cfg_QuickSetEmpty</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if the given node is empty. A node is also considered empty if it doesn't exist.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Write was completed successfuly. LE_NOT_PERMITTED - Node could not be found, or the requested tree could not be accessed. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Absolute or relative path to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6a9b0cede42cd5ab50b3bda4e7855f1"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickSetFloat" ref="ac6a9b0cede42cd5ab50b3bda4e7855f1" args="(const char *path, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#ac6a9b0cede42cd5ab50b3bda4e7855f1">le_cfg_QuickSetFloat</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a 64-bit floating point value to the configuration tree.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Commit was completed successfuly.<ul>
<li>LE_BAD_PARAMETER - Attempted an invalid path for this request.</li>
<li>LE_NOT_PERMITTED - Attempted a path that is out of bounds. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a720ecd8357336f9aca502f2db864d78c"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickSetInt" ref="a720ecd8357336f9aca502f2db864d78c" args="(const char *path, int32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#a720ecd8357336f9aca502f2db864d78c">le_cfg_QuickSetInt</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a signed integer value to the configuration tree.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Commit was completed successfuly.<ul>
<li>LE_BAD_PARAMETER - Attempted an invalid path for this request.</li>
<li>LE_NOT_PERMITTED - Attempted a path that is out of bounds. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5534a2010b8571c4c635f43eed563fb"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_QuickSetString" ref="af5534a2010b8571c4c635f43eed563fb" args="(const char *path, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> <a class="el" href="le__cfg__interface_8h.html#af5534a2010b8571c4c635f43eed563fb">le_cfg_QuickSetString</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a string value to the configuration tree.</p>
<p>When strings are written to the configuration tree, an attempt is made to guess the type of the string.</p>
<p>The algorithim used for this guess is as follows:</p>
<ul>
<li>If the string is the literal value, "true" or "false" then the value is treated as a boolean.</li>
<li>If the string contains nothing but numeric characters, optionally starting with a - then it is treated as an integer.</li>
<li>If the value contains a decimal place, and/or an exponent, it's treated as a float.</li>
<li>All other values are treated as a string.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>- LE_OK - Commit was completed successfuly.<ul>
<li>LE_BAD_PARAMETER - Attempted an invalid path for this request.</li>
<li>LE_NOT_PERMITTED - Attempted a path that's out of bounds. </li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17fa5e63dd1f5a2b7b66c92a76f8c98a"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_RemoveChangeHandler" ref="a17fa5e63dd1f5a2b7b66c92a76f8c98a" args="(le_cfg_ChangeHandlerRef_t addHandlerRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a17fa5e63dd1f5a2b7b66c92a76f8c98a">le_cfg_RemoveChangeHandler</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ChangeHandlerRef_t&#160;</td>
          <td class="paramname"><em>addHandlerRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function removes a handler ... </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addHandlerRef</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1535ef324bc106ad2442b39ef48bb16"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_SetBool" ref="ac1535ef324bc106ad2442b39ef48bb16" args="(le_cfg_iteratorRef_t iteratorRef, const char *path, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#ac1535ef324bc106ad2442b39ef48bb16">le_cfg_SetBool</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a boolean value to the configuration tree. If the iterator is invalid, the write request is ignored.</p>
<p>Only valid during a write transaction.</p>
<p>If the path is empty, then the iterator's current node will be set.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the iterator is invalid, or it's not writeable, this request will be ignored. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Full or relative path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98f4e9c1266082f480834218066b16df"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_SetEmpty" ref="a98f4e9c1266082f480834218066b16df" args="(le_cfg_iteratorRef_t iteratorRef, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a98f4e9c1266082f480834218066b16df">le_cfg_SetEmpty</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear out the leaf's value. If it doesn't exist it will be created, but won't have a value.</p>
<p>If the path is empty, the iterator's current node will be cleared.</p>
<p>Only valid during a write transaction.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the iterator is invalid, or it's not writeable, this request will be ignored. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Absolute or relative path to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abcc99ad3f741550ce20b7013111ded50"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_SetFloat" ref="abcc99ad3f741550ce20b7013111ded50" args="(le_cfg_iteratorRef_t iteratorRef, const char *path, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#abcc99ad3f741550ce20b7013111ded50">le_cfg_SetFloat</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a 64-bit floating point value to the configuration tree. If the iterator is invalid, the write request is ignored.</p>
<p>Only valid during a write transaction.</p>
<p>If the path is empty, the iterator's current node will be set.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the iterator is invalid, or it's not writeable, this request will be ignored. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Full or relative path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65ed6159c4e5f16e10a2eb0475c71f25"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_SetInt" ref="a65ed6159c4e5f16e10a2eb0475c71f25" args="(le_cfg_iteratorRef_t iteratorRef, const char *path, int32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a65ed6159c4e5f16e10a2eb0475c71f25">le_cfg_SetInt</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a signed integer value to the configuration tree. If the iterator is invalid, the write request is ignored.</p>
<p>Only valid during a write transaction.</p>
<p>If the path is empty, the iterator's current node will be set.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the iterator is invalid, or it's not writeable, this request will be ignored. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Full or relative path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ea101446974df3c6578ed8c4e93b59d"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_SetString" ref="a5ea101446974df3c6578ed8c4e93b59d" args="(le_cfg_iteratorRef_t iteratorRef, const char *path, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a5ea101446974df3c6578ed8c4e93b59d">le_cfg_SetString</a> </td>
          <td>(</td>
          <td class="paramtype">le_cfg_iteratorRef_t&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a string value to the configuration tree. If the iterator is invalid, the write request is ignored.</p>
<p>Only valid during a write transaction.</p>
<p>If the path is empty, the iterator's current node will be set.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the iterator is invalid, or it's not writeable, this request will be ignored. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Full or relative path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5228a4832c56fbec5a6448db814d6a49"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_StartClient" ref="a5228a4832c56fbec5a6448db814d6a49" args="(const char *serviceInstanceName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a5228a4832c56fbec5a6448db814d6a49">le_cfg_StartClient</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceInstanceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start the client main thread </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">serviceInstanceName</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04d4fcfe495fe8ff73e7b1bfe9a034a0"></a><!-- doxytag: member="le_cfg_interface.h::le_cfg_StopClient" ref="a04d4fcfe495fe8ff73e7b1bfe9a034a0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__cfg__interface_8h.html#a04d4fcfe495fe8ff73e7b1bfe9a034a0">le_cfg_StopClient</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop the service for the current client thread </p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="le__cfg__interface_8h.html">le_cfg_interface.h</a>      </li>
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless 2014
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.7.6.1
        </div>
    </div>
</body>
</html>
