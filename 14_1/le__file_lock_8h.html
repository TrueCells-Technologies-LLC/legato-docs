<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Legato: framework/c/inc/le_fileLock.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

<link rel="icon" type="image/png" href="favicon.ico">
</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo">
    <img alt="Logo" src="legatoLogo.png"/>
    <div id="projectbrief">Wireless M2M smooth and connected</div>
  </td>
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('le__file_lock_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">framework/c/inc/le_fileLock.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="le__file_lock_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> { <br/>
&#160;&#160;<a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280a887421ec0def966e3ffc65e6bde1f1fc">LE_FLOCK_READ</a>, 
<a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280a058867728a1de4773023f009c2934188">LE_FLOCK_WRITE</a>, 
<a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280adbaa029b7f107f436b170f7c5035420f">LE_FLOCK_APPEND</a>, 
<a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280ac7513bddc0e05c2fff33b25cdd7c73ec">LE_FLOCK_READ_AND_WRITE</a>, 
<br/>
&#160;&#160;<a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280ab92a5dd07207a051c58d0bddafa34bf8">LE_FLOCK_READ_AND_APPEND</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a> { <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9a1bc49344dc291a19f7860fc850376153">LE_FLOCK_OPEN_IF_EXIST</a>, 
<a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9a73c2002338a96be2845fece4bedc1006">LE_FLOCK_REPLACE_IF_EXIST</a>, 
<a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9abc9e73482c03ad0dddf99cf85dba79ad">LE_FLOCK_FAIL_IF_EXIST</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#aac3e11a6f7f363d29b8dbb1eb6c2c287">le_flock_Open</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#a8fdca3e28190ef85e4457ebf009410b5">le_flock_Create</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a> createMode, mode_t permissions)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#add7b73f75a8e7956a397081987458590">le_flock_TryOpen</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#a4f7b134b467adb749401f2ef2ccd92d2">le_flock_TryCreate</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a> createMode, mode_t permissions)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#a457a07dbf8967757322f531d5beb10b6">le_flock_Close</a> (int fd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#ae9a845ef8afe7cb7c4767573a974e5a0">le_flock_OpenStream</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *resultPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#a6444d5e3d885a7c346cba6993534020b">le_flock_CreateStream</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a> createMode, mode_t permissions, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *resultPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#aa4712b501c620401a3f269c5cb34d91a">le_flock_TryOpenStream</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *resultPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#aa1c3c10f1f72a5541f31855b5c2eed98">le_flock_TryCreateStream</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a> createMode, mode_t permissions, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *resultPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__file_lock_8h.html#a8cd7aad1d732c6719097daf0359bf32f">le_flock_CloseStream</a> (FILE *fileStreamPtr)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Legato <a class="el" href="c_flock.html">File Locking API</a> include file.</p>
<p>Copyright (C) Sierra Wireless, Inc. 2013. All rights reserved. Use of this work is subject to license. </p>
</div><hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a5e5400e33a5e10b7c624748a9ce11280"></a><!-- doxytag: member="le_fileLock.h::le_flock_AccessMode_t" ref="a5e5400e33a5e10b7c624748a9ce11280" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>File access modes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>When writing to a file, the writes are always appended to the end of the file by default. When reading from a file, the reads always starts at the beginning of the file by default. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5e5400e33a5e10b7c624748a9ce11280a887421ec0def966e3ffc65e6bde1f1fc"></a><!-- doxytag: member="LE_FLOCK_READ" ref="a5e5400e33a5e10b7c624748a9ce11280a887421ec0def966e3ffc65e6bde1f1fc" args="" -->LE_FLOCK_READ</em>&nbsp;</td><td>
<p>Opens the file for reading. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5e5400e33a5e10b7c624748a9ce11280a058867728a1de4773023f009c2934188"></a><!-- doxytag: member="LE_FLOCK_WRITE" ref="a5e5400e33a5e10b7c624748a9ce11280a058867728a1de4773023f009c2934188" args="" -->LE_FLOCK_WRITE</em>&nbsp;</td><td>
<p>Opens the file for writing. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5e5400e33a5e10b7c624748a9ce11280adbaa029b7f107f436b170f7c5035420f"></a><!-- doxytag: member="LE_FLOCK_APPEND" ref="a5e5400e33a5e10b7c624748a9ce11280adbaa029b7f107f436b170f7c5035420f" args="" -->LE_FLOCK_APPEND</em>&nbsp;</td><td>
<p>Opens the file for writing. Writes will be appended to the end of the file. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5e5400e33a5e10b7c624748a9ce11280ac7513bddc0e05c2fff33b25cdd7c73ec"></a><!-- doxytag: member="LE_FLOCK_READ_AND_WRITE" ref="a5e5400e33a5e10b7c624748a9ce11280ac7513bddc0e05c2fff33b25cdd7c73ec" args="" -->LE_FLOCK_READ_AND_WRITE</em>&nbsp;</td><td>
<p>Opens the file for reading and writing. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5e5400e33a5e10b7c624748a9ce11280ab92a5dd07207a051c58d0bddafa34bf8"></a><!-- doxytag: member="LE_FLOCK_READ_AND_APPEND" ref="a5e5400e33a5e10b7c624748a9ce11280ab92a5dd07207a051c58d0bddafa34bf8" args="" -->LE_FLOCK_READ_AND_APPEND</em>&nbsp;</td><td>
<p>Opens the file for reading and writing. Writes will be appended to the end of the file. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a35d8c575df68d1da52a1048916f7e7d9"></a><!-- doxytag: member="le_fileLock.h::le_flock_CreateMode_t" ref="a35d8c575df68d1da52a1048916f7e7d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>File creation modes specify the action to take when creating a file that already exists. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a35d8c575df68d1da52a1048916f7e7d9a1bc49344dc291a19f7860fc850376153"></a><!-- doxytag: member="LE_FLOCK_OPEN_IF_EXIST" ref="a35d8c575df68d1da52a1048916f7e7d9a1bc49344dc291a19f7860fc850376153" args="" -->LE_FLOCK_OPEN_IF_EXIST</em>&nbsp;</td><td>
<p>Opens the file if it already exists. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a35d8c575df68d1da52a1048916f7e7d9a73c2002338a96be2845fece4bedc1006"></a><!-- doxytag: member="LE_FLOCK_REPLACE_IF_EXIST" ref="a35d8c575df68d1da52a1048916f7e7d9a73c2002338a96be2845fece4bedc1006" args="" -->LE_FLOCK_REPLACE_IF_EXIST</em>&nbsp;</td><td>
<p>Replaces the file if it already exists. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a35d8c575df68d1da52a1048916f7e7d9abc9e73482c03ad0dddf99cf85dba79ad"></a><!-- doxytag: member="LE_FLOCK_FAIL_IF_EXIST" ref="a35d8c575df68d1da52a1048916f7e7d9abc9e73482c03ad0dddf99cf85dba79ad" args="" -->LE_FLOCK_FAIL_IF_EXIST</em>&nbsp;</td><td>
<p>Fails if the file already exists. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a457a07dbf8967757322f531d5beb10b6"></a><!-- doxytag: member="le_fileLock.h::le_flock_Close" ref="a457a07dbf8967757322f531d5beb10b6" args="(int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__file_lock_8h.html#a457a07dbf8967757322f531d5beb10b6">le_flock_Close</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes the file and releases the lock. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor of the file to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8cd7aad1d732c6719097daf0359bf32f"></a><!-- doxytag: member="le_fileLock.h::le_flock_CloseStream" ref="a8cd7aad1d732c6719097daf0359bf32f" args="(FILE *fileStreamPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="le__file_lock_8h.html#a8cd7aad1d732c6719097daf0359bf32f">le_flock_CloseStream</a> </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fileStreamPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes the file stream and releases the lock. </p>

</div>
</div>
<a class="anchor" id="a8fdca3e28190ef85e4457ebf009410b5"></a><!-- doxytag: member="le_fileLock.h::le_flock_Create" ref="a8fdca3e28190ef85e4457ebf009410b5" args="(const char *pathNamePtr, le_flock_AccessMode_t accessMode, le_flock_CreateMode_t createMode, mode_t permissions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="le__file_lock_8h.html#a8fdca3e28190ef85e4457ebf009410b5">le_flock_Create</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a>&#160;</td>
          <td class="paramname"><em>createMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates, opens and locks file.</p>
<p>If the file does not exist, it will be created with the file permissions specified in the arugment permissions (modified by the process's umask). Refer to the POSIX function open(2) for details of mode_t:</p>
<p><a href="http://man7.org/linux/man-pages/man2/open.2.html">http://man7.org/linux/man-pages/man2/open.2.html</a></p>
<p>If the file already exists, then this function will either replace the existing file, open the existing file or fail depending on the createMode argument. The permissions argument is ignored if the file already exists.</p>
<p>The file can be opened for reading, writing or both as specified in the accessMode argument. If accessMode is either LE_FLOCK_WRITE or LE_FLOCK_READ_AND_WRITE, a write lock will be placed on the file, otherwise a read lock will be placed on the file.</p>
<p>If attempting to lock a file that already has an incompatible lock on it, this function will block until the lock can be obtained. This function may block even if it creates the file because creating the file and locking it is not atomic.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>File descriptor to the file specified in pathNamePtr. LE_DUPLICATE if the file already exists and LE_FLOCK_FAIL_IF_EXIST is specified in createMode LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Pointer to the path name of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>Access mode to open the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createMode</td><td>Action to take if the file already exists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>File permissions used when creating the file. See the function header comments for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6444d5e3d885a7c346cba6993534020b"></a><!-- doxytag: member="le_fileLock.h::le_flock_CreateStream" ref="a6444d5e3d885a7c346cba6993534020b" args="(const char *pathNamePtr, le_flock_AccessMode_t accessMode, le_flock_CreateMode_t createMode, mode_t permissions, le_result_t *resultPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* <a class="el" href="le__file_lock_8h.html#a6444d5e3d885a7c346cba6993534020b">le_flock_CreateStream</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a>&#160;</td>
          <td class="paramname"><em>createMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *&#160;</td>
          <td class="paramname"><em>resultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a file, locks it and opens a C standard library buffered file stream to it.</p>
<p>If the file does not exist it will be created with the file permissions specified in the arugment permissions (modified by the process's umask). Refer to the POSIX function open(2) for details of mode_t:</p>
<p><a href="http://man7.org/linux/man-pages/man2/open.2.html">http://man7.org/linux/man-pages/man2/open.2.html</a></p>
<p>If the file already exists then this function will either replace the existing file, open the existing file or fail depending on the createMode argument.</p>
<p>The file can be opened for reading, writing or both as specified in the accessMode argument. If accessMode is either LE_FLOCK_WRITE or LE_FLOCK_READ_AND_WRITE then a write lock will be placed on the file, otherwise a read lock will be placed on the file.</p>
<p>If attempting to lock a file that already has an incompatible lock on it this function will block until the lock can be obtained. This function may block even if it creates the file because creating the file and locking it is not atomic.</p>
<p>If there was an error NULL is returned and resultPtr is set to:</p>
<ul>
<li>LE_DUPLICATE if the file already exists and LE_FLOCK_FAIL_IF_EXIST is specified in createMode.</li>
<li>LE_FAULT if there was an error.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Buffered file stream handle to the file if successful. NULL if there was an error. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Pointer to the path name of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>Access mode to open the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createMode</td><td>Action to take if the file already exists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>File permissions used when creating the file. See the function header comments for more details. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPtr</td><td>Pointer to result code. This can be NULL if the result code is not wanted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac3e11a6f7f363d29b8dbb1eb6c2c287"></a><!-- doxytag: member="le_fileLock.h::le_flock_Open" ref="aac3e11a6f7f363d29b8dbb1eb6c2c287" args="(const char *pathNamePtr, le_flock_AccessMode_t accessMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="le__file_lock_8h.html#aac3e11a6f7f363d29b8dbb1eb6c2c287">le_flock_Open</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opens and locks an existing file.</p>
<p>The file can be open for reading, writing or both as specified in the accessMode argument. If accessMode is either LE_FLOCK_WRITE or LE_FLOCK_READ_AND_WRITE then a write lock will be placed on the file, otherwise a read lock will be placed on the file.</p>
<p>If attempting to lock a file that already has an incompatible lock on it this function will block until the lock can be obtained.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>File descriptor to the file specified in pathNamePtr. LE_NOT_FOUND if the file does not exist. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Pointer to the path name of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>Access mode to open the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9a845ef8afe7cb7c4767573a974e5a0"></a><!-- doxytag: member="le_fileLock.h::le_flock_OpenStream" ref="ae9a845ef8afe7cb7c4767573a974e5a0" args="(const char *pathNamePtr, le_flock_AccessMode_t accessMode, le_result_t *resultPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* <a class="el" href="le__file_lock_8h.html#ae9a845ef8afe7cb7c4767573a974e5a0">le_flock_OpenStream</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *&#160;</td>
          <td class="paramname"><em>resultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Locks an existing file and opens a C standard library buffered file stream to it.</p>
<p>The file can be open for reading, writing or both read and write as specified in the accessMode argument. If accessMode is either LE_FLOCK_WRITE or LE_FLOCK_READ_AND_WRITE then a write lock will be placed on the file, otherwise a read lock will be placed on the file.</p>
<p>If attempting to lock a file that already has an incompatible lock on it, this function will block until the lock can be obtained.</p>
<p>If there was an error NULL is returned and resultPtr is set to:</p>
<ul>
<li>LE_NOT_FOUND if the file does not exist.</li>
<li>LE_FAULT if there was an error.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Buffered file stream handle to the file if successful. NULL if there was an error. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Pointer to the path name of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>Access mode to open the file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPtr</td><td>Pointer to result code. This can be NULL if the result code is not wanted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f7b134b467adb749401f2ef2ccd92d2"></a><!-- doxytag: member="le_fileLock.h::le_flock_TryCreate" ref="a4f7b134b467adb749401f2ef2ccd92d2" args="(const char *pathNamePtr, le_flock_AccessMode_t accessMode, le_flock_CreateMode_t createMode, mode_t permissions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="le__file_lock_8h.html#a4f7b134b467adb749401f2ef2ccd92d2">le_flock_TryCreate</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a>&#160;</td>
          <td class="paramname"><em>createMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates, opens and locks file.</p>
<p>If the file does not exist, it will be created with the file permissions specified in the argument permissions (modified by the process's umask). Refer to the POSIX function open(2) for details of mode_t:</p>
<p><a href="http://man7.org/linux/man-pages/man2/open.2.html">http://man7.org/linux/man-pages/man2/open.2.html</a></p>
<p>If the file already exists, this function will either replace the existing file, open the existing file or fail depending on the createMode argument. The permissions argument is ignored if the file already exists.</p>
<p>The file can be opened for reading, writing or both as specified in the accessMode argument. f accessMode is either LE_FLOCK_WRITE or LE_FLOCK_READ_AND_WRITE, a write lock will be placed on the file, otherwise a read lock will be placed on the file.</p>
<p>If attempting to lock a file that already has an incompatible lock on it, this function will fail and return LE_WOULD_BLOCK immediately. This function may fail with LE_WOULD_BLOCK even if it creates the file because creating the file and locking it is not atomic.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>File descriptor to the file specified in pathNamePtr. LE_DUPLICATE if the file already exists and LE_FLOCK_FAIL_IF_EXIST is specified in createMode LE_WOULD_BLOCK if there is already an incompatible lock on the file. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Pointer to the path name of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>Access mode to open the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createMode</td><td>Action to take if the file already exists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>File permissions used when creating the file. See the function header comments for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1c3c10f1f72a5541f31855b5c2eed98"></a><!-- doxytag: member="le_fileLock.h::le_flock_TryCreateStream" ref="aa1c3c10f1f72a5541f31855b5c2eed98" args="(const char *pathNamePtr, le_flock_AccessMode_t accessMode, le_flock_CreateMode_t createMode, mode_t permissions, le_result_t *resultPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* <a class="el" href="le__file_lock_8h.html#aa1c3c10f1f72a5541f31855b5c2eed98">le_flock_TryCreateStream</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a>&#160;</td>
          <td class="paramname"><em>createMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *&#160;</td>
          <td class="paramname"><em>resultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a file, locks it and opens a C standard library buffered file stream to it.</p>
<p>If the file does not exist, it will be created with the file permissions specified in the arugment permissions (modified by the process's umask). Refer to the POSIX function open(2) for details of mode_t:</p>
<p><a href="http://man7.org/linux/man-pages/man2/open.2.html">http://man7.org/linux/man-pages/man2/open.2.html</a></p>
<p>If the file already exists, this function will either replace the existing file, open the existing file or fail depending on the createMode argument.</p>
<p>The file can be opened for reading, writing or both as specified in the accessMode argument. If accessMode is either LE_FLOCK_WRITE or LE_FLOCK_READ_AND_WRITE then a write lock will be placed on the file, otherwise a read lock will be placed on the file.</p>
<p>If attempting to lock a file that already has an incompatible lock on it, this function will return NULL immediately and set resultPtr to LE_WOULD_BLOCK. This function may fail with LE_WOULD_BLOCK even if it creates the file because creating the file and locking it is not atomic.</p>
<p>If there was an error NULL is returned and resultPtr is set to:</p>
<ul>
<li>LE_DUPLICATE if the file already exists and LE_FLOCK_FAIL_IF_EXIST is specified in createMode.</li>
<li>LE_WOULD_BLOCK if there is already an incompatible lock on the file.</li>
<li>LE_FAULT if there was an error.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Buffered file stream handle to the file if successful. NULL if there was an error. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Pointer to the path name of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>Access mode to open the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createMode</td><td>Action to take if the file already exists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>File permissions used when creating the file. See the function header comments for more details. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPtr</td><td>Pointer to result code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add7b73f75a8e7956a397081987458590"></a><!-- doxytag: member="le_fileLock.h::le_flock_TryOpen" ref="add7b73f75a8e7956a397081987458590" args="(const char *pathNamePtr, le_flock_AccessMode_t accessMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="le__file_lock_8h.html#add7b73f75a8e7956a397081987458590">le_flock_TryOpen</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opens and locks an existing file.</p>
<p>The file can be open for reading, writing or both as specified in the accessMode argument. If accessMode is either LE_FLOCK_WRITE or LE_FLOCK_READ_AND_WRITE, a write lock will be placed on the file, otherwise a read lock will be placed on the file.</p>
<p>If attempting to lock a file that already has an incompatible lock on it, this function will fail and return LE_WOULD_BLOCK immediately.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>File descriptor to the file specified in pathNamePtr. LE_NOT_FOUND if the file does not exist. LE_WOULD_BLOCK if there is already an incompatible lock on the file. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Pointer to the path name of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>Access mode to open the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4712b501c620401a3f269c5cb34d91a"></a><!-- doxytag: member="le_fileLock.h::le_flock_TryOpenStream" ref="aa4712b501c620401a3f269c5cb34d91a" args="(const char *pathNamePtr, le_flock_AccessMode_t accessMode, le_result_t *resultPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* <a class="el" href="le__file_lock_8h.html#aa4712b501c620401a3f269c5cb34d91a">le_flock_TryOpenStream</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *&#160;</td>
          <td class="paramname"><em>resultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Locks an existing file and opens a C standard library buffered file stream to it.</p>
<p>The file can be open for reading, writing or both read and write as specified in the accessMode argument. If accessMode is either LE_FLOCK_WRITE or LE_FLOCK_READ_AND_WRITE then a write lock will be placed on the file, otherwise a read lock will be placed on the file.</p>
<p>If attempting to lock a file that already has an incompatible lock on it, this function will return NULL immediately and set resultPtr to LE_WOULD_BLOCK.</p>
<p>If there was an error NULL is returned and resultPtr is set to:</p>
<ul>
<li>LE_NOT_FOUND if the file does not exist.</li>
<li>LE_WOULD_BLOCK if there is already an incompatible lock on the file.</li>
<li>LE_FAULT if there was an error.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Buffered file stream handle to the file if successful. NULL if there was an error. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Pointer to the path name of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>Access mode to open the file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPtr</td><td>Pointer to result code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="le__file_lock_8h.html">le_fileLock.h</a>      </li>
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless 2014
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.7.6.1
        </div>
    </div>
</body>
</html>
