<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: Advanced Smack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <img alt="Logo" src="legatoLogo.png"/>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('basic_security_smack_advanced.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Advanced Smack </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="basicSecuritySmackAdvanced_smack"></a>
Smack Implementation</h1>
<p>SMACK (Simplified Mandatory Access Control Kernel) is a kernel feature that provides mandatory access control.</p>
<p>The key feature of MAC (mandatory access control) is the ability of a centralized entity to set access policy to system resources. The easiest way to understand MAC is to compare it to Linux's default access control system.</p>
<p>Linux's default access control policy is governed by the permission bits on system resources (ie. files, directories, devices, etc.). The permission bits on files may be modified by the owner of the resource, a process with the same user ID as the resource. The access control policy is at the discretion of the resource owner, hence this system is classified as DAC (discretionary access control). Note also that with DAC, policies are set in a distributed manner because there are often many users in a system each setting the access policy for its own resources.</p>
<p>In contrast MAC policies are set for all resources on the system by a centralized entity.</p>
<p>Linux's DAC has many known weaknesses that can lead to security leaks. So MAC is often used to overcome some of the short comings of DAC for systems that require a higher level of security.</p>
<p>SMACK is not the only MAC solution available. It is, however, a solution that was built with simplicity as one of its main objectives. Its simplicity means that it is not flexible enough to handle all use cases but it also means that for the majority of use cases it will be easier to setup and maintain.</p>
<p>SMACK supplements Linux's DAC system, that is to say, DAC permissions are checked first and only if access is granted SMACK permissions are then checked. As a result SMACK can only limit access it cannot grant access beyond DAC permissions.</p>
<p>SMACK uses 'labels' on resources (objects in SMACK terminology) and processes (subjects) to determine access. Labels on resources can only be set by a privileged process (see <a class="el" href="basic_security_smack_advanced.html#basicSecuritySmackAdvanced_privProcess">Privileged Processes</a>).</p>
<p>There are a number of single character labels ("_", "^", "*", "?", "@") that have special meanings.</p>
<p>SMACK restricts read/write/execute access based on the label of the subject and the label of the object according to the following rules. </p>
<pre class="fragment"> 1. Any access requested by a task labelled "*" is denied.
 2. A read or execute access requested by a task labelled "^" is permitted.
 3. A read or execute access requested on an object labelled "_" is permitted.
 4. Any access requested on an object labelled "*" is permitted.
 5. Any access requested by a task on an object with the same label is permitted.
 6. Any access requested that is explicitly defined in the loaded rule set is permitted.
 7. Any other access is denied.
</pre><p>As alluded to in rule 6 above explicit rules can be added for specific labels. Explicit rules define the access rights that a subject label can have on an object label. See the c_smack_setRules section for details. Only privileged processes can set rules.</p>
<h1><a class="anchor" id="basicSecuritySmackAdvanced_privProcess"></a>
Privileged Processes</h1>
<p>Privileged processes are processes with the CAP_MAC_OVERRIDE capability. However, it is also possible to configure the system such that the CAP_MAC_OVERRIDE is honoured only for processes with a certain label. This configuration allows the system to restrict processes which are root (have CAP_MAC_OVERRIDE) but do not have the proper SMACK label.</p>
<h1><a class="anchor" id="basicSecuritySmackAdvanced_smack_c_smack_assignLabels"></a>
Assigning SMACK Labels</h1>
<p>Use smack_SetMyLabel() to set the SMACK label for the calling process. The calling process must be a privileged process. Setting SMACK labels for other processes is not possible.</p>
<p>To set the SMACK label for file system objects use smack_SetLabel(), again the calling process must be privileged.</p>
<h1><a class="anchor" id="basicSecuritySmackAdvanced_smack_c_smack_setRules"></a>
Setting SMACK Rules</h1>
<p>Use smack_SetRule() to set an explicit SMACK rule that gives a specified subject access to a specified object.</p>
<h1><a class="anchor" id="basicSecuritySmackAdvanced_supervisor"></a>
Smack Supervisor</h1>
<p>SMACK policies are set by the Legato startup scripts, the Legato Installer and the Legato Supervisor.</p>
<p>By default system files have the "_" SMACK label which means that everyone has read and execute access to them. The Legato startup scripts are responsible for setting SMACK labels for system files that require special permission handling. For example, the /dev/null file is given the label "*" by the start up scripts so that it is fully accessible by everyone. Additionally, the Legato startup scripts makes sure that the Legato Supervisor and Installer have the 'admin' SMACK label.</p>
<p>The Legato Installer sets SMACK labels for all application bundled files. The SMACK label for each app is unique to the app.</p>
<p>The Supervisor sets SMACK labels for "framework" daemons, processes for applications, sandbox directories and it also sets SMACK rules for IPC bindings.</p>
<p>Framework daemons are given the SMACK label "framework".</p>
<p>All processes are given the same SMACK label as the application they belong to. All app labels are unique.</p>
<p>SMACK rules are set so that IPC bindings between applications will work. For example if we have a client app that needs to talk to the server app, the following rules will be set:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&#39;clientAppLabel&#39;</span> rw <span class="stringliteral">&#39;serverAppLabel&#39;</span>     <span class="comment">// client has read-write access to server.</span></div>
<div class="line"><span class="stringliteral">&#39;serverAppLabel&#39;</span> rw <span class="stringliteral">&#39;clientAppLabel&#39;</span>     <span class="comment">// server has read-write access to client.</span></div>
</div><!-- fragment --><p>Sandboxed directories are given labels that correspond to the application's access rights to the directory. For example, generally an application only has read and execute permission to its sandbox /bin directory. So the /bin will have the following properties:</p>
<pre class="fragment"> owner = root
 group = root
 DAC permissions = ------r-x
 SMACK label = 'AppLabelrx'
</pre><p>The Supervisor also sets up the SMACK rule:</p>
<p>'AppLabel' rx 'AppLabelrx'</p>
<p>so that the application has the proper access to the directory. The reason that an application's directories are given different labels than the application itself is so that if an IPC binding is present the remote application has access to talk to the local app but does not have direct access to the local app's files.</p>
<p>All bundled files within an application's sandbox is given the SMACK label of the app. This is to support passing of file descriptors from one application to another. Note however, that the file descriptor cannot be passed on to a third application.</p>
<h1><a class="anchor" id="c_sup_smack_limitations"></a>
SMACK Limitations</h1>
<p>Extended attributes are used to store the SMACK label and although this feature is available on all file systems we currently use, one key feature is missing. When a new file is created the file should inherit the SMACK label of the creator but because this feature is missing our current implementation of SMACK has the following limitations.</p>
<ul>
<li>Mqueue file system will always set new files to "_" label. Which means we can't control access between apps that use MQueues.</li>
<li>Tmpfs always sets new files to "*" label which means we can't totally control access to files created in sandboxes because sandboxes use tmpfs. This is only an issue when file descriptors for the created files are passed over IPC to another app. The other app can then pass that fd onto a third app and so on.</li>
<li>Yaffs2/UBIFS do not set any label for newly created files. This causes an issue with the config daemon that has the label "framework" but its created files do not have any labels. To work around this the config daemon must run as root and the 'onlycap' SMACK file must not be set. This means that there is limited protection because all root processes have the ability to change SMACK labels on files.</li>
<li>QMI sockets are currently set to "*" because some applications need to write to them. Ideally, the QMI socket file would be given a label such as "qmi" and a rule would be created to only allow access to the application that requires it. However, there currently isn't a way to specify this in the xdef file.</li>
</ul>
<hr/>
<p>Copyright (C) Sierra Wireless Inc. Use of this work is subject to license. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.6
        </div>
    </div>
</body>
</html>
